p({"class": "foam.nanos.test.Test", "id": "Contact Tests", "description": "Tests related to contacts.", "server": false, "code": "/**\n * Tests for the Contacts feature.\n */\n\nrunTests();\n\nasync function runTests() {\n  var adminContext = x;\n\n  await resetTestData();\n  await Cannot_Create_Contact_Without_First_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_Long_First_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_First_Name_Containing_Number(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Without_Last_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_Long_Last_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_Last_Name_Containing_Number(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Without_Organization(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Without_Email(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Invalid_Email(adminContext);\n  await resetTestData();\n  await Cannot_Create_Second_Contact_With_Same_Email(adminContext);\n  await resetTestData();\n  await Can_Create_Contact(adminContext);\n  await resetTestData();\n  await Can_Update_Contact(adminContext);\n}\n\nasync function resetTestData() {\n  // Delete the test contacts.\n  await x.contactDAO\n    .where(foam.mlang.predicate.Eq.create({\n      arg1: net.nanopay.contacts.Contact.EMAIL,\n      arg2: 'devon@example.com'\n    }))\n    .removeAll_(x, 0, 1000, null, null);\n}\n\n/**\n * Utility method for tests that check if an error was thrown. \n */\nasync function Test_Throws(testText, expectedErrorMessage, fn) {\n  var threw = false;\n  var actualErrorMessage = '';\n  try {\n    await fn();\n  } catch(err) {\n    threw = true;\n    actualErrorMessage = err.message;\n  }\n  test(threw && actualErrorMessage === expectedErrorMessage, testText);\n  if ( threw && actualErrorMessage !== expectedErrorMessage ) {\n    print(`INFO: Expected to get '${expectedErrorMessage}' as the error message but got '${actualErrorMessage}' instead.`);\n  } else if ( ! threw  ) {\n    print(`INFO: Didn't throw an error.`);\n  }\n}\n\nasync function Cannot_Create_Contact_Without_First_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact without `firstName`, a required field.',\n    'First name is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Long_First_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact with a first name longer than 70 characters.',\n    'First name cannot exceed 70 characters.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_First_Name_Containing_Number(context) {\n  await Test_Throws(\n    'Cannot create a contact with a first name that contains a number.',\n    'First name cannot contain numbers.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: '5up3rm4n',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Last_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact without `lastName`, a required field.',\n    'Last name is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Long_Last_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact with a last name longer than 70 characters.',\n    'Last name cannot exceed 70 characters.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Last_Name_Containing_Number(context) {\n  await Test_Throws(\n    'Cannot create a contact with a last name that contains a number.',\n    'Last name cannot contain numbers.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: '5up3rm4n',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Organization(context) {\n  await Test_Throws(\n    'Cannot create a contact without `organization`, a required field.',\n    'Organization is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Email(context) {\n  await Test_Throws(\n    'Cannot create a contact without `email`, a required field.',\n    'Email is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Invalid_Email(context) {\n  await Test_Throws(\n    'Cannot create a contact with an empty string for an email address.',\n    'Email is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: '',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n  await Test_Throws(\n    'Cannot create a contact without anything before the @ in an email address.',\n    'Invalid email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: '@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n  await Test_Throws(\n    'Cannot create a contact with only a TLD in the email address.',\n    'Invalid email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Second_Contact_With_Same_Email(context) {\n  await Test_Throws(\n    'Cannot create two contacts with the same email address.',\n    'You already have a contact with that email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }));\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'OtherGuy',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Can_Create_Contact(context) {\n  var threw = false;\n  var result;\n  try {\n    result = await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n      email: 'devon@example.com',\n      firstName: 'Devon',\n      lastName: 'Carlyle',\n      organization: 'ExampleCo'\n    }));\n  } catch (err) {\n    threw = true;\n  }\n  var passed = ! threw &&\n    result.email === 'devon@example.com' &&\n    result.firstName === 'Devon' &&\n    result.lastName === 'Carlyle' &&\n    result.organization === 'ExampleCo';\n  test(passed, `User in '${context.user.group}' group can create a contact.`);\n}\n\nasync function Can_Update_Contact(context) {\n  var threw = false;\n  var result = await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n    email: 'devon@example.com',\n    firstName: 'Devon',\n    lastName: 'Carlyle',\n    organization: 'ExampleCo'\n  }));\n  try {\n    result.organization = 'Different';\n    result = await context.user.contacts.put(result);\n  } catch (err) {\n    threw = true;\n    print(err.message);\n  }\n  var passed = ! threw &&\n    result.email === 'devon@example.com' &&\n    result.firstName === 'Devon' &&\n    result.lastName === 'Carlyle' &&\n    result.organization === 'Different';\n  test(passed, `User in '${context.user.group}' group can update a contact.`);\n}\n"})
p({"class": "net.nanopay.contacts.AuthenticatedContactDAOTest", "id": "AuthenticatedContactDAOTest", "description": "Tests the functionality of the AuthenticatedContactDAO DAO decorator."})
p({"class":"foam.nanos.test.Test","id":"transactionFlow-User Payee with no BankAccount","status":2,"code":"import foam.dao.ArraySink;\nimport foam.core.X;\nimport foam.mlang.predicate.*;\nimport foam.nanos.auth.User;\nimport foam.util.SafetyUtil;\nimport net.nanopay.contacts.Contact;\nimport net.nanopay.invoice.model.Invoice;\nimport net.nanopay.account.Account;\nimport net.nanopay.bank.CABankAccount;\nimport net.nanopay.account.DigitalAccount;\nimport net.nanopay.tx.model.Transaction;\nimport net.nanopay.tx.model.TransactionStatus;\nimport net.nanopay.bank.BankAccountStatus;\nimport net.nanopay.invoice.model.InvoiceStatus;\nimport net.nanopay.invoice.model.PaymentStatus;\n\nuser = x.get(\"user\");\nuserDAO = x.get(\"localUserDAO\");\naccountDAO = x.get(\"accountDAO\");\ncontactDAO = x.get(\"contactDAO\");\ninvoiceDAO = x.get(\"invoiceDAO\");\n\n/* Confirm Clean UP */\n\nuserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"unicorn@princess.com\")).removeAll();\nuserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"prince@caspen.com\")).removeAll();\nuserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"fox@example.com\")).removeAll();\naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account\")).removeAll();\naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account1\")).removeAll();\naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account2\")).removeAll();\ncontactDAO.where(foam.mlang.MLang.EQ(Contact.EMAIL, \"fox@example.com\")).removeAll();\ninvoiceDAO.removeAll();\n\n/* Main User */\nsmeUser = new User();\nsmeUser.setGroup(\"smeBusinessAdmin\");\nsmeUser.setFirstName(\"Unicorn\");\nsmeUser.setLastName(\"Princess\");\nsmeUser.setEmail(\"unicorn@princess.com\");\nsmeUser.setEmailVerified(true);\n\nsmeUser   = userDAO.put(smeUser);\nX smeUserContext = foam.util.Auth.sudo(x, smeUser);\ntransactionDAO = smeUserContext.get(\"transactionDAO\").inX(smeUserContext);\n\n// FLOW 1 create test where User(smeUser) sends money via invoice1 to Ablii User(test1User)\n\n// Test User 1 \ntest1User = new User();\ntest1User.setGroup(\"smeBusinessAdmin\");\ntest1User.setFirstName(\"Prince\");\ntest1User.setLastName(\"Caspen\");\ntest1User.setEmail(\"prince@caspen.com\");\ntest1User.setEmailVerified(true);\n\ntest1User = userDAO.put(test1User);\nX test1UserContext = foam.util.Auth.sudo(x, test1User);\ntransactionDAO1 = test1UserContext.get(\"transactionDAO\").inX(test1UserContext);\n\n// bank account for smeUser\naccount = new CABankAccount();\naccount.setName(\"bank test account\");\naccount.setDenomination(\"CAD\");\naccount.setAccountNumber(\"12345678\");\naccount.setInstitution(1);\naccount.setBranchId(\"12345\");\naccount.setStatus(BankAccountStatus.VERIFIED);\n\naccount = smeUser.getAccounts(smeUserContext).put(account);\n\n// Create a payable invoice with the test1User as the payee.\ninvoice1Payable = new Invoice();\ninvoice1Payable.setPayeeId(test1User.getId());\ninvoice1Payable.setAmount(1);\ninvoice1Payable.setDestinationCurrency(\"CAD\");\ninvoice1Payable.setAccount(account.getId());\ninvoice1Payable = smeUser.getExpenses(smeUserContext).put(invoice1Payable);\n\nAccount digAccount = (Account) accountDAO.find(invoice1Payable.getDestinationAccount());\n\n// TEST 1 : Was destination account correctly set?\ntest(digAccount != null && digAccount instanceof DigitalAccount && digAccount.getOwner() == smeUser.getId() && invoice1Payable.getStatus() == InvoiceStatus.UNPAID, \"Test 1: User created Invoice dst account set to payer's default digitalAccount\");\n\n// Saving account balance for below test\npriorBalance = digAccount.findBalance(smeUserContext);\n\n// Pay the invoice.\ntxn = new Transaction();\ntxn.setPayeeId(test1User.getId());\ntxn.setDestinationAccount(invoice1Payable.getDestinationAccount());\ntxn.setInvoiceId(invoice1Payable.getId());\ntxn.setAmount(invoice1Payable.getAmount());\ntxn.setPayerId(smeUser.getId());\ntxn.setSourceAccount(invoice1Payable.getAccount());\ntxn = transactionDAO.put(txn);\n\ninvoice1Payable = smeUser.getExpenses(smeUserContext).find(invoice1Payable);\n// TEST 2 : Was destination account correctly set?\ntest(invoice1Payable.getStatus() == InvoiceStatus.IN_TRANSIT, \"Test 2: in-transit Status check - prior cashin to holding account\");\n\n\n// Update for test\ntxn.setStatus(TransactionStatus.COMPLETED);\ntxn = transactionDAO.put(txn);\ntransferBalance = digAccount.findBalance(x);\ninvoice1Payable = smeUser.getExpenses(smeUserContext).find(invoice1Payable);\n\n// TEST 3: Is the status set correctly? and does the account balance reflect the proper balance after a transaction\ntest(invoice1Payable.getStatus() == InvoiceStatus.PENDING_ACCEPTANCE && (transferBalance - priorBalance) == invoice1Payable.getAmount(), \"Test 3: Invoice paid by moving money to payer's default digitalAccount\");\n\n// Testing whether we can withdraw money from Payer's DigitalAccount, arbitrarily.\nString errMsg = \"\";\ntry{\n\ntxn = new Transaction();\ntxn.setPayeeId(smeUser.getId());\ntxn.setSourceAccount(digAccount.getId());\ntxn.setDestinationAccount(account.getId());\ntxn.setAmount(invoice1Payable.getAmount());\ntxn.setPayerId(smeUser.getId());\n\ntxn = transactionDAO.put(txn);\n}catch(Exception e){\nerrMsg = e.toString();;\n}\n// TEST 4:  Is holding payment safe?\ntest(errMsg.contains(\"Insufficient balance\") , \"Test 4: Can not withdraw money from Payer's DigitalAccount when a portion of balance is reserved in holding.\");\n\n// Mimic flow of depositing money that was sent to a User\n// User would see the invoice. If they click accept payment the below logic is executed\n// Difference is test1User.getId() would actually be user in current context and\n// account1 would be the chosen user account\n\n// For purpose of testing balance and status\ninvoice1Receivable = test1User.getSales(test1UserContext).find(invoice1Payable.getId());\n\n/* bank account for test1User */\naccount1 = new CABankAccount();\naccount1.setName(\"bank test account1\");\naccount1.setDenomination(\"CAD\");\naccount1.setAccountNumber(\"87654321\");\naccount1.setInstitution(1);\naccount1.setBranchId(\"54321\");\naccount1.setStatus(BankAccountStatus.VERIFIED);\n\naccount1 = test1User.getAccounts(test1UserContext).put(account1);\n\n// Info for below test\ntransferBalance = digAccount.findBalance(x);\n\n// Receive funds - User accepts payment selecting account1 as dst account. \ntxn1 = new Transaction();\ntxn1.setSourceAccount(invoice1Receivable.getDestinationAccount());\ntxn1.setDestinationAccount(account1.getId());\ntxn1.setInvoiceId(invoice1Receivable.getId());\ntxn1.setAmount(invoice1Receivable.getAmount());\n\ntxn1 = transactionDAO1.put(txn1);\n\n// For purpose of testing balance and status\ninvoice1Receivable = test1User.getSales(test1UserContext).find(invoice1Receivable);\npaymentStatus = invoice1Receivable.getStatus();\ntxn1.setStatus(TransactionStatus.COMPLETED);\ntxn1 = transactionDAO.put(txn1);\n\n// TEST 5:  Is the status set correctly?\ntest(paymentStatus == InvoiceStatus.DEPOSITING_MONEY, \"Test 5: Invoice paid by moving money from payer's default DigitalAccount to User who accepted payment\");\n\n\n// Flow 2: create test where User(smeUser) sends money via invoice2 to an external Contact(test2Contact)\n\ntest2Contact = new Contact();\ntest2Contact.setEmail(\"fox@example.com\");\ntest2Contact.setFirstName(\"Fox\");\ntest2Contact.setLastName(\"McCloud\");\ntest2Contact.setOrganization(\"Example Company\");\n\ntest2Contact = smeUser.getContacts(smeUserContext).put(test2Contact);\n\n// Create a payable invoice with the test2Contact as the payee.\ninvoice2Payable = new Invoice();\ninvoice2Payable.setPayeeId(test2Contact.getId());\ninvoice2Payable.setAmount(1);\ninvoice2Payable.setDestinationCurrency(\"CAD\");\ninvoice2Payable.setAccount(account.getId());\ninvoice2Payable = smeUser.getExpenses(smeUserContext).put(invoice2Payable);\n\ndigAccount2 = (Account) accountDAO.find(invoice2Payable.getDestinationAccount());\n\n// TEST 6:  Was destination account correctly set?\ntest(digAccount2 != null && digAccount2 instanceof DigitalAccount && digAccount.getOwner() == smeUser.getId() && invoice2Payable.getStatus() == InvoiceStatus.UNPAID, \"Test 6: Ablii User created Invoice dst account set to payer's default DigitalAccount\");\n\n\n// Saving account balance for below test\npriorBalance = digAccount.findBalance(smeUserContext);\n\n// Pay the invoice.\ntxn2 = new Transaction();\ntxn2.setPayeeId(test2Contact.getId());\ntxn2.setDestinationAccount(invoice2Payable.getDestinationAccount());\ntxn2.setInvoiceId(invoice2Payable.getId());\ntxn2.setAmount(invoice2Payable.getAmount());\ntxn2.setPayerId(smeUser.getId());\ntxn2.setSourceAccount(invoice2Payable.getAccount());\ntxn2 = transactionDAO.put(txn2);\n// For purpose of testing balance\ntxn2.setStatus(TransactionStatus.COMPLETED);\ntxn2 = transactionDAO.put(txn2);\n\n// Update for test\ntransferBalance = digAccount2.findBalance(x);\ninvoice2Payable = smeUser.getExpenses(smeUserContext).find(invoice2Payable);\n\n// TEST 7\ntest(invoice2Payable.getStatus() == InvoiceStatus.PENDING_ACCEPTANCE && (transferBalance - priorBalance) == invoice2Payable.getAmount(), \"Test 7: Invoice paid by moving money to payer's default DigitalAccount\");\n\n// Mimic flow for Contact becoming User\ntest3User = new User();\ntest3User.setGroup(\"smeBusinessAdmin\");\ntest3User.setFirstName(\"Fox\");\ntest3User.setLastName(\"MkCloud\");\ntest3User.setEmail(\"fox@example.com\");\ntest3User.setEmailVerified(true);\n\ntest3User = userDAO.put(test3User);\nX test3UserContext = foam.util.Auth.sudo(x, test3User);\ntransactionDAO2 = test3UserContext.get(\"transactionDAO\").inX(test3UserContext);\n\n// Note: test3User.getSales(test3UserContext).find(invoice2Payable.getId()) = null, \n// because this test is not linking invoices of contacts to their equivalent user. \n// This feature is reserved for the onboarding of a contact.\n// Below a put into the invoiceDAO will mimic the onboarding of a Contact - a SMEInvoiceDAO decorator will set things right\ninvoice2Receivable = test3User.getSales(test3UserContext).put(invoice2Payable);\n\n// Test 8\ntest(invoice2Receivable.getPayeeId() == test3User.getId(), \"Test 8: testing whether the invoice PayeeId is updated in a put to the invoiceDAO test3User.getId() = \" + test3User.getId() + \" invoice2Receivable.getPayeeId() \" + invoice2Receivable.getPayeeId());\n\n/* bank account for test3User */\naccount2 = new CABankAccount();\naccount2.setName(\"bank test account2\");\naccount2.setDenomination(\"CAD\");\naccount2.setAccountNumber(\"87654300\");\naccount2.setInstitution(1);\naccount2.setBranchId(\"54300\");\naccount2.setStatus(BankAccountStatus.VERIFIED);\n\naccount2 = test3User.getAccounts(test3UserContext).put(account2);\n\n// Info for below test\ndigAccount = (Account) accountDAO.find(invoice2Receivable.getDestinationAccount());\ntransferBalance = digAccount.findBalance(x);\n\n// Receive funds - User accepts payment selecting account1 as dst account. \ntxn3 = new Transaction();\ntxn3.setSourceAccount(invoice2Receivable.getDestinationAccount());\ntxn3.setDestinationAccount(account2.getId());\ntxn3.setInvoiceId(invoice2Receivable.getId());\ntxn3.setAmount(invoice2Receivable.getAmount());\ntxn3 = transactionDAO2.put(txn3);\n\n// Updates: For purpose of testing balance and status\ninvoice2Receivable = test3User.getSales(test3UserContext).find(invoice2Receivable);\npaymentStatus = invoice2Receivable.getStatus();\ntxn3.setStatus(TransactionStatus.COMPLETED);\ntxn3 = transactionDAO.put(txn3);\n\n// TEST 9\ntest(paymentStatus == InvoiceStatus.DEPOSITING_MONEY, \"Test 9: Invoice paid by moving money from payer's default DigitalAccount\");\n\n// Flow 3: create test to confirm a non-ablii/sme user does not go through the holding account flow\n\n// Mimic flow for Contact becoming User\ntest4User = new User();\ntest4User.setFirstName(\"Fo\");\ntest4User.setLastName(\"Bar\");\ntest4User.setEmail(\"foo@bar.com\");\ntest4User.setEmailVerified(true);\n\n// Mimic flow for Contact becoming User\ntest5User = new User();\ntest5User.setFirstName(\"BAR\");\ntest5User.setLastName(\"Foo\");\ntest5User.setEmail(\"bar@foo.com\");\ntest5User.setEmailVerified(true);\n\ntest4User = userDAO.put(test4User);\ntest5User = userDAO.put(test5User);\nX test4UserContext = foam.util.Auth.sudo(x, test4User);\ntransactionDAO3 = test4UserContext.get(\"transactionDAO\").inX(test4UserContext);\n\n/* bank account for test3User */\naccount3 = new CABankAccount();\naccount3.setName(\"bank test account3\");\naccount3.setDenomination(\"CAD\");\naccount3.setAccountNumber(\"87654300\");\naccount3.setInstitution(1);\naccount3.setBranchId(\"54300\");\naccount3.setStatus(BankAccountStatus.VERIFIED);\n\naccount3 = test4User.getAccounts(test4UserContext).put(account3);\n\ninvoice0 = new Invoice();\ninvoice0.setPayeeId(test5User.getId());\ninvoice0.setAmount(1);\ninvoice0.setDestinationCurrency(\"CAD\");\ninvoice0.setAccount(account.getId());\ninvoice0 = test4User.getExpenses(test4UserContext).put(invoice0);\n\n// Basic Trans\ntxn4 = new Transaction();\ntxn4.setSourceAccount(account3.getId());\ntxn4.setInvoiceId(invoice0.getId());\ntxn4.setAmount(1);\ntxn4 = transactionDAO3.put(txn4);\n\ninvoice0 = (Invoice)test4User.getExpenses(test4UserContext).find(invoice0.getId());\n// TEST 10: non-ablii/sme user will not follow the above tested transaction flow?\ntest(invoice0.getStatus() != InvoiceStatus.PENDING_ACCEPTANCE, \"Test 10: Confirm a non-ablii/sme user will not follow the above tested transaction flow. InvoiceStatus: \" + invoice0.getStatus() + \" payee = \"+invoice0.getPayeeId() + \" payer = \" + invoice0.getPayerId() );\n\n/* Clean UP */\nuserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"unicorn@princess.com\")).removeAll();\nuserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"prince@caspen.com\")).removeAll();\nuserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"fox@example.com\")).removeAll();\nuserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"foo@bar.com\")).removeAll();\nuserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"bar@foo.com\")).removeAll();\naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account\")).removeAll();\naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account1\")).removeAll();\naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account2\")).removeAll();\naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account3\")).removeAll();\ncontactDAO.where(foam.mlang.MLang.EQ(Contact.EMAIL, \"fox@example.com\")).removeAll();\ninvoiceDAO.where(foam.mlang.MLang.EQ(Invoice.ID, invoice1Payable.getId())).removeAll();\ninvoiceDAO.where(foam.mlang.MLang.EQ(Invoice.ID, invoice1Receivable.getId())).removeAll();\ninvoiceDAO.where(foam.mlang.MLang.EQ(Invoice.ID, invoice2Payable.getId())).removeAll();\ninvoiceDAO.where(foam.mlang.MLang.EQ(Invoice.ID, invoice2Receivable.getId())).removeAll();","output":""})