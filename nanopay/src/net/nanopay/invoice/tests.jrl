p({"class":"net.nanopay.invoice.AuthenticatedInvoiceDAOTest","id":"AuthenticatedInvoiceDAOTest"})
p({
  "class":"foam.nanos.test.Test",
  "id":"Approval tests",
  "code":"""
import foam.dao.*;
import foam.nanos.auth.User;
import foam.util.Auth;

import net.nanopay.account.Account;
import net.nanopay.bank.BankAccountStatus;
import net.nanopay.bank.CABankAccount;
import net.nanopay.invoice.model.Invoice;
import net.nanopay.invoice.model.InvoiceStatus;
import net.nanopay.invoice.model.PaymentStatus;
import net.nanopay.tx.model.Transaction;
import net.nanopay.admin.model.ComplianceStatus;

accountDAO = (DAO) x.get("accountDAO");
bareUserDAO = (DAO) x.get("bareUserDAO");
invoiceDAO = (DAO) x.get("invoiceDAO");
transactionDAO = (DAO) x.get("transactionDAO");

////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// SETUP ////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


bareUserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, "employee1@example.com")).removeAll();
employee1 = new User();
employee1.setEmail("employee1@example.com");
employee1.setGroup("smeBusinessEmployee");
employee1.setEmailVerified(true); // Required to send or receive money.
employee1.setCompliance(ComplianceStatus.PASSED);
employee1 = bareUserDAO.put(employee1);
employee1Context = Auth.sudo(x, employee1);


accountDAO.where(foam.mlang.MLang.EQ(Account.NAME, "Approval Tests employee 1 test account")).removeAll();
employee1BankAccount = new CABankAccount();
employee1BankAccount.setName("Approval Tests employee 1 test account");
employee1BankAccount.setDenomination("CAD");
employee1BankAccount.setAccountNumber("12345678");
employee1BankAccount.setInstitution(1);
employee1BankAccount.setBranchId("12345");
employee1BankAccount.setStatus(BankAccountStatus.VERIFIED);

// previously, there where no permissions in place to prevent unauthorized groups from setting bank account statuses
// after adding bank account status permissions, this test would not work
// this is because in the normal .put method, despite the bank account status being set to verified in the lines above
// it goes through a cloning procedure in the permissionedPropertyDAO, where it checks if the employee1's group (sme) 
// has permissions to read/write bank account status, since they do not it would instead reset the status property to unverified
// that is why we must use the override put_, in order to set the employee bank account using the global context permissions
employee1BankAccount = employee1.getAccounts(employee1Context).put_(x, employee1BankAccount);


bareUserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, "employee2@example.com")).removeAll();
employee2 = new User();
employee2.setEmail("employee2@example.com");
employee2.setGroup("smeBusinessEmployee");
employee2.setEmailVerified(true); // Required to send or receive money.
employee2.setCompliance(ComplianceStatus.PASSED);
employee2 = bareUserDAO.put(employee2);
employee2Context = Auth.sudo(x, employee2);


bareUserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, "approver@example.com")).removeAll();
approver = new User();
approver.setEmail("approver@example.com");
approver.setGroup("smeBusinessApprover");
approver.setEmailVerified(true); // Required to send or receive money.
approver.setCompliance(ComplianceStatus.PASSED);
approver = bareUserDAO.put(approver);
approverContext = Auth.sudo(x, approver);


accountDAO.where(foam.mlang.MLang.EQ(Account.NAME, "Approval Tests approver test account")).removeAll();
approverBankAccount = new CABankAccount();
approverBankAccount.setName("Approval Tests approver test account");
approverBankAccount.setDenomination("CAD");
approverBankAccount.setAccountNumber("87654321");
approverBankAccount.setInstitution(1);
approverBankAccount.setBranchId("12345");
approverBankAccount.setStatus(BankAccountStatus.VERIFIED);

// please see the same as above with the employee1BankAccount on why we use put_ instead of put
approverBankAccount = approver.getAccounts(approverContext).put_(x, approverBankAccount);


///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// TEST CODE ///////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////


invoice = new Invoice();
invoice.setAmount(1);
invoice.setPayerId(employee1.getId());
invoice.setPayeeId(employee2.getId());
invoice.setDestinationCurrency("CAD");
invoice.setAccount(employee1BankAccount.getId());
invoice = invoiceDAO.inX(employee1Context).put(invoice);
invoiceStatusIsCorrect = invoice.getStatus() == InvoiceStatus.UNPAID;
paymentStatusIsCorrect = invoice.getPaymentMethod() == PaymentStatus.NONE;
if ( ! invoiceStatusIsCorrect ) {
  print("DEBUG: Invoice status is " + invoice.getStatus());
}
if ( ! paymentStatusIsCorrect ) {
  print("DEBUG: Payment status is " + invoice.getPaymentMethod());
}
test(invoiceStatusIsCorrect && paymentStatusIsCorrect, "When an employee creates an invoice, the invoice status is UNPAID and the payment status is NONE.");


transaction = new Transaction();
transaction.setSourceAccount(invoice.getAccount());
transaction.setDestinationAccount(invoice.getDestinationAccount());
transaction.setPayerId(invoice.getPayerId());
transaction.setPayeeId(invoice.getPayeeId());
transaction.setAmount(invoice.getAmount());
transaction.setInvoiceId(invoice.getId());
threw = false;
message = "";
try {
  transactionDAO.inX(employee1Context).put(transaction);
  invoice = invoiceDAO.inX(employee1Context).find(invoice.id);
  invoiceStatusIsCorrect = invoice.getStatus() == InvoiceStatus.PENDING_APPROVAL;
  paymentStatusIsCorrect = invoice.getPaymentMethod() == PaymentStatus.PENDING_APPROVAL;
  if ( ! invoiceStatusIsCorrect ) {
    print("DEBUG: Invoice status is " + invoice.getStatus());
  }
  if ( ! paymentStatusIsCorrect ) {
    print("DEBUG: Payment status is " + invoice.getPaymentMethod());
  }
} catch (Throwable t) {
  threw = true;
  message = t.getMessage();
  print("DEBUG: " + message);
}
test(! threw && invoiceStatusIsCorrect && paymentStatusIsCorrect, "When an employee tries to pay an invoice the invoice is set to a PENDING_APPROVAL state.");


invoice = new Invoice();
invoice.setAmount(1);
invoice.setPayerId(approver.getId());
invoice.setPayeeId(employee2.getId());
invoice.setDestinationCurrency("CAD");
invoice.setAccount(approverBankAccount.getId());
invoice = invoiceDAO.inX(approverContext).put(invoice);
test(invoice.getStatus() == InvoiceStatus.UNPAID && invoice.getPaymentMethod() == PaymentStatus.NONE, "When an approver creates an invoice, the invoice status is UNPAID and the payment status is NONE.");


transaction = new Transaction();
transaction.setSourceAccount(invoice.getAccount());
transaction.setDestinationAccount(invoice.getDestinationAccount());
transaction.setPayerId(invoice.getPayerId());
transaction.setPayeeId(invoice.getPayeeId());
transaction.setAmount(invoice.getAmount());
transaction.setInvoiceId(invoice.getId());
threw = false;
message = "";
try {
  transactionDAO.inX(approverContext).put(transaction);
} catch (Throwable t) {
  threw = true;
  message = t.getMessage();
  print("DEBUG: " + message);
}
test(! threw, "When an approver tries to pay an invoice, it works as expected.");
"""
})
