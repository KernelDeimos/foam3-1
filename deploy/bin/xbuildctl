#!/bin/bash

##########################################################
#
# ctl
#
# This code is a protected work and subject to domestic and
# international copyright law(s). A complete listing of authors of
# this work is readily available. Additionally, source code is, by
# its very nature, confidential information and inextricably contains
# trade secrets and other information proprietary, valuable and
# sensitive to Redknee, no unauthorised use, disclosure, manipulation
# or otherwise is permitted, and may only be used in accordance with
# the terms of the licence agreement entered into with Redknee Inc.
# and/or its subsidiaries.
#
# Copyright © Redknee Inc. and its subsidiaries. All Rights Reserved.
#
# Author : Joel Hughes
# $Date: 2010-11-01 17:56:33 -0400 (Mon, 01 Nov 2010) $
# $Rev: 331 $
#
################################
#
# Purpose:
#   Process Control for Redknee suite of tools
#    Provides start, stop, status and process monitoring
#
#  General
#    Every execution of $CTL generates two notice logs:
#    "$CTL <command> initiated" followed by
#    "$CTL <command> complate",  where <command> is the
#   requested action such as 'start'
#
# Environment Requirements
#    XBUILD_VERSION
#      Example: 1_4_234
#
#    XBUILD_HOME
#      Optional, required if running control script outside of bin
#
# Parameter description:
#
#  start [process_name ]
#    Starts all processs.
#    If process_name supplied will start just the one process.
#    CRONTAB (see variables below).
#    Start will not start an already running process.
#
#  stop [process_name ]
#    Stops all processs.
#    If process_name supplied will stop just the one process.
#    CRONTAB (see variables below).
#
#  status
#    Print verbose status of each process
#    Process name is listed along with either
#    ACTIVE or INACTIVE.
#
#  stat
#    Print non-verbose status of each process.
#    Each process is listed as either
#    ACTIVE or INACTIVE without the process name.
#   Use this call for chaining control scripts
#
#  restart
#    Stop all processes.
#    Clean the Cocoon repository (cache)
#    Start all processes.
#
#  pmon
#    Check if all processes are running, start if not.
#    For each process in the process list:
#    - verify if running using 'status'
#    - if not running, start with 'start' and issue a warn log.
#    Call from rkctl on regular interval.
#    (see Process Monitor below)
#
#  kill
#    Force kill all processes. See force_kill() for
#    patterm matching of kill processes.
#
#  version
#    Responds with the application version
#
#  enable
#    Make an application available for execution after
#    if has been disabled (see below).
#
#  disable
#    Make an application unavailable for execution. Disable an 
#    an application during a maintenance window so that it is
#    not automatically restarted by PMON or other cron services.
#
# Process Monitor
#    The $CTL can be used as process monitor.  Ideally
#    $CTL is called repeatedly every time period with
#    the 'pmon' option (see Parameter description for
#    a description of pmon).  Used in conjuction with 'cron'
#    the rkctl can install a crontab file which calls
#   $CTL every few minutes (see redknee setup for example).
#
#  Adminstrative/Deployment Options
#  reset
#    Remove the $CTL lock file.  A lock file is generated
#    by $CTL when executing any command with the exception
#    of 'status'. The lock file prevents multiple instances
#    of $CTL from running symultaneously.
#    If for some reason no command is being executed but the
#    lock file remains, it can be removed with this command.
#    USE WITH CAUTION.
#
#
#  Development Notes
#
#  Adding additional processes
#  1. duplicate and modify a control_xxx() block.
#     implement 'start', 'stop', and 'status'
#  2. add process to 'process[]' list in main()
#
#  Notes on the lock file
#  In an attempt to ensure a proper cleanup of the lock
#  file in all circumstances, interrupts are trapped.
#  Upon trapping an interrupt, we remove the lock file.
#  Notice that interrupt 0 is trapped, which is normal
#  program termination. We rely on the the trap of interrupt
#  0 to clear the lock file on normal program termination.
#
#
#  NOTE: code best viewed with tab stop set at 2. (:set tabstop=2)
#
#
############################################################

# Ensure applications are not started by root
if [[ $UID -eq 0 ]]; then
  echo "$0 must not be run as root"
  exit 1;
fi

if [ "$1" == "-release" ]; then

  # version specified as parameter
  PROJECT_VERSION=$2
  version=$2

  # skip over release value
  shift 2

  export PROJECT_HOME=/opt/redknee/tool/xbuild/client/$PROJECT_VERSION

elif [ -z "$XBUILD_VERSION" ]; then

  PROJECT_VERSION=current
  export PROJECT_HOME=/opt/redknee/tool/xbuild/client/$PROJECT_VERSION

  # determine real home - resolve symlinks as find_java_process fails on symlinks
  sym=`ls -ld $PROJECT_HOME`
  dir=`dirname $PROJECT_HOME`
  version=${sym##*-\>}
  version=`echo $version`
  if [[ -n "$version" ]]; then
    PROJECT_HOME=$dir/$version
  fi

else

  PROJECT_VERSION=$XBUILD_VERSION
  version=$PROJECT_VERSION
  export PROJECT_HOME=/opt/redknee/tool/xbuild/client/$PROJECT_VERSION

fi

COMMAND=$1
TARGET=$2
ARGS=$3

# PROJECT_NAME, BASE_PORT, CTL moved to shrc.project

. $PROJECT_HOME/etc/shrc.local $ARGS

#### Local Environment Variables

# Process id base directory
PID_DIR=/tmp/redknee/$CTL/$PROJECT_VERSION/proc

# Current working directory  - store ior files
CWD=$PROJECT_HOME/work

# Working directory of the scripts
BIN_DIR=$PROJECT_HOME/bin

# Log directory and filename
LOG_DIR=$PROJECT_HOME/log

# default log
DEFAULT_LOG=$LOG_DIR/$CTL.log

# Lock file
LOCKFILE=$PID_DIR/$CTL.lck

# Disabled Dir
DISABLED_DIR=/opt/redknee/var/disabled/$CTL

# set up the debug
#DEBUG="ON"

##### Functions

#################################
# Function: find_process
# Purpose:
#   A running process will have a stored pid.
#   Test for the pid file, extract the pid, test for a matching process
#   If running, return the pid, else pid will be empty (null).
# Input
#   PIDFILE path and file name containing pid to check in process table
# Output
# Returns
#   PID process id if process id file found and process id in process table
#       otherwise null
# Throws
#################################

find_process()
{
    PIDFILE=$1

    STORED_PID=`cat $PIDFILE 2>/dev/null`
    if [[ -n "$STORED_PID" ]]; then
        #
        # there's a pid file; is in the process table.
        #
      # cut the first column of ps -g command
      ps -ef | grep $STORED_PID | grep -v "grep" | cut -b9-15 |
      while read PID; do
        if [[ $PID = $STORED_PID ]]; then
          echo $PID
        fi
      done
    fi
}


#################################
# Function: find_java_process
# Purpose:
#   Under Linux the VM forked on start, subsequently forked again
#   so the process id returned is not that of the final VM.
#   Hence we have to find the process some other way.
#   Locate a java process based on command line arguments. The
#   arguments passed must be unique to a VM.
# Input
#   ARG unique command line argument to distinguish a particular instance.
# Output
# Returns
#   PID process id if process id file found and process id in process table
#       otherwise null
# Throws
#################################
find_java_process()
{
  ARGS="$*"
  if [ -x "/usr/java/bin/jps" ]; then
    echo `/usr/java/bin/jps -v | grep $ARGS | grep XBUILD | cut -d" " -f1`
  elif [ -x "/usr/ucb/ps" ]; then
    echo `/usr/ucb/ps auxwww | grep XBUILD | grep $ARGS | grep -v grep | cut -b9-15`
  else
    # if jps or lps isn't available, we'll have to use ps, but
    # it isn't very reliable.
    # When there is no match on $ARGS then many PIDs are returned.
    echo `ps -ef | grep XBUILD | grep $ARGS | grep -v grep | cut -b9-15`
  fi
}


find_child_process()
{
    PARENT=$1
    if [[ -z "$PARENT" ]]; then
      return
    fi

    FOUND=''

    # cut the first column of ps -g command
      ps -ef | grep $PARENT | grep -v "grep" | cut -b9-15,17-21 |
      while read PID1 PID2; do
        # first line in list is table header
        # take the first pid after finding the parent
        if [[ $PID1 = $PARENT ]]; then
          FOUND="found"
        elif [[ -n "$FOUND" ]]; then
          echo $PID2
        fi
      done
}

#################################
# Function: control_process
# Purpose:
#   Start or stop a single process.
#   Supports the following 'action' commands
#   exec - process is blindly started, no check is made if already running
#   start - process is started after first checking if not running.  The
#            pid is captured and stored for testing and stop
#   stop - process is stopped with a kill command.  The process is
#          checked that is first running.
#   shutdown - process accepts a shutdown or stop command.
#              pass process string is executed, PID is removed
#   stop.core - a special stop sequence for Framework applications.
#   start/stop make use of process ids.  When a process is started, its
#   pid is captured and stored in a file $PROC/$PIDNAME.pid.  When the
#   the process is later stopped, the process id is retrieved from the
#   $PROC/$PIDNAME.pid file and varified against the process table (ps).
#
# Input
#   ACTION action to perform [start|stop|status]
#   PIDNAME name to store pid under
#   CMD real name of process to start/stop including path
#   OPTIONS options passed to command
#   LOG complete path to log file (optional if calling status)
# Output
# Returns
#   PID process id of started or stopped process
# Throws
#################################

control_process()
{
    ACTION=$1
    PIDNAME=$2
    CMD=$3
    OPTIONS=$4
    LOG=$5

    # set log if not provided
    if [[ -z "$LOG" ]]; then
      LOG=$LOG_DIR/$PID_NAME.log
    fi

    # Output messages
    STARTMSG="Starting $PIDNAME..."
    STOPMSG="Shutting down $PIDNAME..."
    EXECMSG="Executing $PIDNAME..."
    WARNRUNMSG="$PIDNAME already running."
    WARNNOTRUNMSG="$PIDNAME not running."
    SLEEPMSG="Waiting 30 seconds for $PIDNAME to shutdown."

    # Determine if process already running
    PID=`find_process $PID_DIR/$PIDNAME.pid`

    # body of function.
    # We are either starting or stopping.
    case $ACTION in
        'start_msg')    echo $STARTMSG ;;
        'stop_msg')     echo $STOPMSG ;;

        'exec')

            # start,stop commands dont necessarily run under
            # the process id that is reported when they start
            echo $EXECMSG
            $CMD $OPTIONS 1>> $LOG 2>&1 &
            ;;

        'start')

            if [[ -z "$PID" ]]; then
              sleep 15
              echo $STARTMSG

              # Start the process
              $CMD $OPTIONS 1>> $LOG 2>&1 &

              # capture process id of last background process
              PID=$!
              #and store it
              echo $PID > $PID_DIR/$PIDNAME.pid

              # output process id to control file
# TODO: fix output redirection as this replaces the log file
# and subsequent system.out/err is lost.
#              D=`date`
#              echo "$PIDNAME $PID STARTED ${D}" >> $LOG
#              echo "GC_LOG_FILE ${GC_LOG}" >> $LOG
#              if [ -x "/usr/ucb/ps" ]; then
#                echo `/usr/ucb/ps -auxwww $PID` >> $LOG
#              else
#                echo "${OPTIONS}" >> $LOG
#              fi

            elif [[ -n "$PID" ]]; then
              echo $WARNRUNMSG
            fi
            ;;

        'stop')
          if [[ -n "$PID" ]]; then
            echo $STOPMSG
            echo "*** `date` **** $PIDNAME : Dumping thread info  ***" >> $LOG
            # do a thread dump
            kill -s 3 $PID 1>> $LOG 2>&1
            # give it sometime to dump
            sleep 2

            # attempt graceful shutdown
            kill -s 2 $PID >/dev/null 2>&1

            # check for process termination
            sleep 15 
            PID=`find_process $PID_DIR/$PIDNAME.pid`
            if [[ -n "$PID" ]]; then
              echo $SLEEPMSG
              sleep 30

              PID=`find_process $PID_DIR/$PIDNAME.pid`
              if [ -n "$PID" ]; then
                kill -s KILL $PID 1>> /dev/null 2>&1
              fi
            fi

            # remove old pid file
            rm -f "$PID_DIR/$PIDNAME.pid" 1>> $LOG 2>&1

            echo "$PIDNAME $PID STOPPED `date`" >> $LOG

          elif [[ -z "$PID" ]]; then
             echo $WARNNOTRUNMSG
          fi
          ;;

        'shutdown')
            if [[ -n "$PID" ]]; then
              echo $STOPMSG
              echo "*** `date` **** $PIDNAME : Dumping thread info  ***" >> $LOG
              # do a thread dump
              kill -s 3 $PID 1>> $LOG 2>&1
              # give it sometime to dump
              sleep 2

              # run the shutdown command
              $CMD $OPTIONS 1>> $LOG 2>&1

              PID=`find_process $PID_DIR/$PIDNAME.pid`
              if [[ -n "$PID" ]]; then
                echo $SLEEPMSG
                sleep 30

                # if not shutdown, perform stop
                PID=`find_process $PID_DIR/$PIDNAME.pid`
                if [ -n "$PID" ]; then
                  kill -s KILL $PID 1>> /dev/null 2>&1
                  control_process stop $PIDNAME $CMD $OPTIONS $LOG
                fi
              else
                rm -f "$PID_DIR/$PIDNAME.pid" 1>> $LOG 2>&1
              fi

            elif [[ -z "$PID" ]]; then
               echo $WARNNOTRUNMSG
            fi
            ;;

         'stop.core')
            # PIDNAME is PROJECT_NAME
            # CMD is PROJECT_HOME
            # OPTIONS is SOCKET_PORT
            if [[ -z "$PID" ]]; then
              PID=`find_java_process ${CMD}`
            fi
            if [[ -n "$PID" ]]; then
              echo $STOPMSG
              echo "*** `date` **** ${PIDNAME} : Dumping thread info  ***" >> $LOG
              # do a thread dump
              kill -s 3 $PID 1>> $LOG 2>&1
              # give it sometime to dump
              sleep 2
              # store for subsequent stop
              echo $PID > $PID_DIR/${PIDNAME}.pid

             (echo login rkshutdown nw5dt3hs; sleep 1; echo shutdown; sleep 10) | telnet localhost ${OPTIONS} 1>> $LOG 2>&1

              # time to shutdown
              # This alarm sent from stop()
              #${CMD}/bin/sendxlog 10857 CTL ${PIDNAME} "" "${PIDNAME}"
              #sleep 10

              PID=`find_process $PID_DIR/$PIDNAME.pid`
              if [[ -z "$PID" ]]; then
                PID=`find_java_process ${PROJECT_HOME}`
              fi
              if [[ -n "$PID" ]]; then
                control_process stop ${PIDNAME} "" "" $LOG
              fi
            else
              echo $WARNNOTRUNMSG
            fi
            ;;

        'status')
            if [[ -n "$PID" ]]; then
                echo "$PIDNAME is running"
            else
                echo "$PIDNAME is stopped"
            fi
            ;;
    esac

    # returning a non zero value for success will
    # invoke interrupt trap and fail the script
    return 0
}

#################################
# Function
#    find_param
# Purpose
#    Finds a string in the rest of the parameter list
# Input
#    $1 the string to be found
#    $2..$k the rest of the strings
# Output
#    0 if found, 1 if not
#################################

find_param()
{
  let count=1
  found="1"

  for proc in $* ;  do
    if (( $count > 1 )); then
      # debug
      # echo $proc
      if [[ $proc = $1 ]]; then
        found="0"
      fi
    fi
    let count="count + 1"
  done
  return ${found}
}


#################################
# force_kill
#   force kill PROJECT_HOME Redknee process 
#
#################################

force_kill()
{
  # try to use ucb/ps
  # as it provides a complete
  # command listing so we know
  # exactly what we are deleting

  threaddump

  if [ -x "/usr/ucb/ps" ]; then
    /usr/ucb/ps auxwww | grep "$PROJECT_HOME" | grep -v grep | grep -v $CTL | cut -b9-15 |
    while read PID; do
      if [[ -n "$PID" ]]; then
        kill -s KILL $PID >/dev/null 2>&1
      fi
    done
  fi
}

#################################
# threaddump
#   Generate a threaddump
#
#################################

threaddump()
{
  if [ -x "/usr/ucb/ps" ]; then
    /usr/ucb/ps auxwww | grep "$PROJECT_HOME" | grep -v grep | grep -v $CTL | cut -b9-15 |
    while read PID; do
      if [[ -n "$PID" ]]; then
        kill -s 3 $PID 1>> $DEFAULT_LOG 2>&1
        # give it sometime to dump
        sleep 2
      fi
    done
  fi
}


#################################
# init
#   ensure proper system configuration before
#   launching any apps
#   Check for:
#   - proc directory
#   - set the current working directory
#   so we know where the orb ior files are
#   so we can delete them on a stop/restart
#   Use the pid directory (in /tmp) so that pid files
#   are cleaned up even on an unexpected reboot.
#    - set traps
#
#    NOTE: we treat 'status' differently
#    multiple instances of status are allowed.
#
#################################

init()
{
  # set traps
  trap interrupt 0 1 2 15

  # test set proc directory
  if [[ ! -d "$PID_DIR" ]]; then
    mkdir -p $PID_DIR 1>> $DEFAULT_LOG 2>&1
  fi

  # set working directory
  #cd $PID_DIR 1>> $DEFAULT_LOG 2>&1
  mkdir -p $CWD >> $DEFAULT_LOG 2>&1
  cd $CWD 1>> $DEFAULT_LOG 2>&1

  # proctect against multiple instances of $CTL
  if [[ "$COMMAND" != "status" ]]; then
    testSetLock
  fi
  # catching trap 0 will remove lock file
}


#################################
# interrupt
#    handled interrupts
#    - clear lock file
#    - report interrupt
#    - stop specific process if possible
#
#################################

interrupt()
{
  #echo -n "Interrupt! '$?'"

    # zero is normal exit, but if we
    # don't catch it, we also don't
    # get control-c and such

  if [[ "$?" != "0" ]]; then
    echo -n "Interrupt!"
    if [[ "$COMMAND" == "start" ]]; then
      if [[ -n "$TARGET" ]]; then
        echo -n "  Attempting to stop $TARGET..."
        control_$TARGET stop
      fi
    fi

    echo " Cleaning up..."
    rm -rf $CWD/* 1>> $DEFAULT_LOG 2>&1
  fi

  # clear the lock file
  if [[ "$COMMAND" != "status" ]]; then
    resetLock
  fi

  exit
}

#################################
# to_start
#   start all process if not running
#################################

to_start()
{
   for NAME in ${process[*]}; do
    control_$NAME start
  done
}

#################################
# to_status
#   status all processes
#################################
to_status()
{
  echo ""
  echo $0
  echo ""
  echo "PROCESS             DESCRIPTION                             STATUS"
  echo "------------------------------------------------------------------"

   for NAME in ${process[*]}; do
    echo -n "$NAME"
    (( pad = 20 - ${#NAME} ))
    while [[ $pad -gt 0 ]]; do
      echo -n ' '
      (( pad -= 1 ))
    done

    control_$NAME status verbose
  done
}

#################################
# to_stop
#    stop all processes
#   in reverse order of starting
#################################

to_stop()
{
  # invert list
  size=${#process[*]}
   for NAME in ${process[*]}; do
    size=$((size - 1))
    invert[$size]=$NAME
  done

  # walk through inverted list
   for NAME in ${invert[*]}; do
    control_$NAME stop
  done
}

#################################
# to_pmon
#   Check status of each process
#    if not ACTIVE, stop, start
#################################

to_pmon()
{
  for NAME in ${process[*]}; do
    #heartbeat - now handled by the application
    #${PROJECT_HOME}/bin/sendxlog 12725 CTL PMON "" "${NAME}" > /dev/null

    RESULT=`control_$NAME status`
    if [[ -z "$RESULT" ]]; then
      ${PROJECT_HOME}/bin/sendxlog 10857 CTL PMON "attempting restart" "${NAME}" > /dev/null
      control_$NAME stop
      control_$NAME start
    fi
  done

  # Send pmon command to all sub processes
   for NAME in ${process_sub[*]}; do
    control_$NAME pmon
  done
}

#################################
# to_debugstatus
#    check the debug loggin status and the directories
#################################

to_debugstatus()
{


  echo -n "application is ${PROJECT_NAME}"


  cd ${PROJECT_HOME}/etc

  if [[ -n `ls | grep "Config.xml"` ]];
  then
  echo -n " running framework 1.4"
  echo ""
  echo ""
  ${JAVA_HOME}/bin/java -version
  echo ""
  echo "The logs are located in ${PROJECT_HOME}/log"
  echo ""
  echo "SYSTEM SETTING                                    STATUS"
    echo "--------------------------------------------------------"
    local NAME=debug
    echo -n "$NAME"
      (( pad = 50 - ${#NAME} ))
      while [[ $pad -gt 0 ]]; do
        echo -n ' '
        (( pad -= 1 ))
      done

  local var6=`cat Config.xml | sed 1,/^.*SystemFilterLoggerConfig/d`
  local var7=`echo $var6 | sed s/debugEnabled\>/:/ | cut -d ":" -f 2 | cut -d "<" -f 1`
  if [[ "$var7" == "y" ]];
  then
  echo -n 'Enabled'
  else
  echo -n 'Disabled'
  fi
  echo ""
  local NAME="internal debug"
    echo -n "$NAME"
      (( pad = 50 - ${#NAME} ))
      while [[ $pad -gt 0 ]]; do
        echo -n ' '
        (( pad -= 1 ))
      done

  local var7=`echo $var6 | sed s/internalDebugEnabled\>/:/ | cut -d ":" -f 2 | cut -d "<" -f 1`
  if [[ "$var7" == "y" ]];
  then
  echo -n 'Enabled'
  else
  echo -n 'Disabled'
  fi

  echo ""
  local NAME="snmp severity threshold"
    echo -n "$NAME"
      (( pad = 50 - ${#NAME} ))
      while [[ $pad -gt 0 ]]; do
        echo -n ' '
        (( pad -= 1 ))
      done

  local var7=`echo $var6 | sed s/snmpSeverityThreshold\>/:/ | cut -d ":" -f 2 | cut -d "<" -f 1`

  get_enum_xml $var7
  echo ""
  echo ""
  echo source predicate list

  local var7=`echo $var6 | sed s/sourcePredicateList\>/:/ | cut -d ":" -f 2`
  local var8=`echo $var7 | sed s/"<\/sourcePredicateList>"/:/ | cut -d ":" -f 1 | sed s/"<beans>"/""/ | sed s/"<\/beans>"/""/`
  local var9=`echo $var8 | sed s/"<bean>"/:/ | sed s/"<\/bean>"/""/`

  local a=2
  local var10=`echo $var9 | cut -d ":" -f $a`
  echo "SYSTEM FILTER                                     STATUS"
    echo "--------------------------------------------------------"
  while [ -n "$var10" ]
  do
    parse_xml $var10
    a=$((a+1))
    var10=`echo $var9 | cut -d ":" -f $a`
    echo ""
  done





  else

  echo -n " running framework 5"
  echo ""
  echo ""
  ${JAVA_HOME}/bin/java -version
  echo ""
  cd ${PROJECT_HOME}/../journal/
  local var4=`grep "(let ((ctx (getContext ctx \"core\"))) (homeCreateOrStore (.get ctx com.redknee.framework.xlog.logger.FileLoggerConfigHome.class) (let ((b (com.redknee.framework.xlog.logger.FileLoggerConfig.))) (setBeanProperty b \"FileName\"" *  | tail -n 1`
  if [[ -n "$var4" ]];
  then
  local name=`echo $var4 | sed s/FileName/:/ | cut -d ":" -f 2 | cut -d "\"" -f 3`
  if [[ `echo $var4 | grep -c "Path"` != 0 ]];then
  local path=`echo $var4 | sed s/Path/:/ | cut -d ":" -f 2 | cut -d "\"" -f 3`
  else
  local path="${PROJECT_HOME}/log"
  fi
  echo "logs are stored in ${path}/${name}"
  fi
  echo ""

  echo "SYSTEM SETTING                                    STATUS"
    echo "--------------------------------------------------------"

  local var3=`grep -h "(let ((ctx (getContext ctx \"core\"))) (let ((b (.get ctx com.redknee.framework.xlog.logger.SystemFilterLoggerConfig.class))) (setBeanProperty b \"severityThreshold\"" * | tail -n 1`
  local NAME="severity threshold"
  echo -n "$NAME"
      (( pad = 50 - ${#NAME} ))
      while [[ $pad -gt 0 ]]; do
        echo -n ' '
        (( pad -= 1 ))
      done
  if [[ -n "$var3" ]];
  then

  get_enum $var3
  else
  echo -n info
  fi
  echo ""
  local var3=`grep -h "(let ((ctx (getContext ctx \"core\"))) (let ((b (.get ctx com.redknee.framework.xlog.logger.SystemFilterLoggerConfig.class))) (setBeanProperty b \"internalSeverityThreshold\"" * | tail -n 1`
  local NAME="internal severity threshold"
  echo -n "$NAME"
      (( pad = 50 - ${#NAME} ))
      while [[ $pad -gt 0 ]]; do
        echo -n ' '
        (( pad -= 1 ))
      done
  if [[ -n "$var3" ]];
  then

  get_enum $var3
  else
  echo -n info
  fi
  echo ""
  local var4=`grep -h "(let ((ctx (getContext ctx \"core\"))) (let ((b (.get ctx com.redknee.framework.xlog.logger.SystemFilterLoggerConfig.class))) (setBeanProperty b \"snmpSeverityThreshold\"" * | tail -n 1`
  local NAME="snmp severity threshold"
  echo -n "$NAME"
      (( pad = 50 - ${#NAME} ))
      while [[ $pad -gt 0 ]]; do
        echo -n ' '
        (( pad -= 1 ))
      done
  if [[ -n "$var3" ]];
  then

  get_enum $var3
  else
  echo -n info
  fi
  echo ""
        local var=`grep -h "(let ((ctx (getContext ctx \"core\"))) (let ((b (.get ctx com.redknee.framework.xlog.logger.SystemFilterLoggerConfig.class))) (setBeanProperty b \"sourcePredicateList\" (let ((c (java.util.ArrayList.)))" * | tail -n 1 | cut -d ':' -f 2`
        if [[ -n "$var" ]];then

        echo "SYSTEM FILTER                                     STATUS"
    echo "--------------------------------------------------------"
        local var2=`echo $var | sed s/"(let ((ctx (getContext ctx \"core\"))) (let ((b (.get ctx com.redknee.framework.xlog.logger.SystemFilterLoggerConfig.class))) (setBeanProperty b \"sourcePredicateList\" (let ((c (java.util.ArrayList.)))"/""/`

        parse_list $var2
        fi

        fi



}

parse_list()
{

  local var=$*;

  local a=2
  local var3=`echo $var|sed s/.add/:/g`

  local var2=`echo $var3|cut -d ":" -f $a`

  while [ -n "$var2"  ]
  do


    get_value $var2
    echo ""
    let "a += 1"

    local var4=`echo $var3 | sed s/"$var2"/""/`

    var3=$var4

    var2=`echo $var3 | cut -d ":" -f $a`

  done



}

parse_xml()
{


  local var=$*
  local var9=`echo $var | sed s/"<sourcePattern>"/:/ | sed s/"<\/sourcePattern>"/:/ | cut -d ":" -f 2`
  local NAME=$var9
    echo -n "$NAME"
      (( pad = 50 - ${#NAME} ))
      while [[ $pad -gt 0 ]]; do
        echo -n ' '
        (( pad -= 1 ))
      done

  local var9=`echo $var8 | sed s/"<severityThreshold>"/:/ | sed s/"<\/severityThreshold>"/:/ | cut -d ":" -f 2`
  get_enum_xml $var9
}

get_value()
{
  local var=$*;
  local var2=`echo $var | grep "SourcePattern"`
  if [[ -n "$var2" ]]; then
  local var3=`echo $var2 | sed s/SourcePattern/:/g`
  local var4=`echo $var3 | cut -d ":" -f 2 | cut -d "\"" -f 3`

  echo -n "$var4"
      (( pad = 50 - ${#var4} ))
      while [[ $pad -gt 0 ]]; do
        echo -n ' '
        (( pad -= 1 ))
      done
  local var5=`echo $var3 | cut -d ":" -f 2`
  get_enum $var5
  else
  local NAME="com.redknee.*"
  echo -n "$NAME"
      (( pad = 50 - ${#NAME} ))
      while [[ $pad -gt 0 ]]; do
        echo -n ' '
        (( pad -= 1 ))
      done
  get_enum $var
  fi
}

get_enum()
{
  local var=$*

  local var3=`echo $var | grep "SeverityEnum"`
  if [[ -n "$var3" ]];
  then
  var2=`echo $var | sed s/SeverityEnum.get/":"/ | cut -d ":" -f 2 | cut -d " " -f 2 | cut -d "s" -f 1`

  case "$var2" in

  0)
  echo -n debug
  ;;
  1)
  echo -n info
  ;;
  2)
  echo -n minor
  ;;
  3)
  echo -n major
  ;;
  4)
  echo -n critical
  ;;
  5)
  echo -n clear
  ;;
  esac
  else
  echo -n info
  fi

}

get_enum_xml()
{
  local var=$*

  case "$var" in

  0)
  echo -n debug
  ;;
  1)
  echo -n info
  ;;
  2)
  echo -n minor
  ;;
  3)
  echo -n major
  ;;
  4)
  echo -n critical
  ;;
  5)
  echo -n clear
  ;;
  esac


}

################################
# to_log_er
#    return the last date time stamp of the last er
#################################

to_log_er()
{
     var=`ls -t ${PROJECT_HOME}/../log/er | head -n 2 |tail -1`
     var2=`ls -t ${PROJECT_HOME}/log | head -n 1 |tail -1`
     echo $PROJECT_NAME
    if [[ -n "$var" ]];
    then
    echo ${PROJECT_HOME}/../log/er/$var time stamp of last er entry
    cut -d ',' -f 1,2 ${PROJECT_HOME}/../log/er/$var | tail -1
    fi

    if [[ -n "$var2" ]];
    then
    echo ${PROJECT_HOME}/log/$var2 time stamp of last application log entry
    cut -d ',' -f 1 ${PROJECT_HOME}/log/$var2 | tail -1
    fi
}

#################################
# to_jmap
#   jmap all process 
#################################

to_jmap()
{
  for NAME in ${process[*]}; do
    control_$NAME jmap
  done
}

#################################
# to_jmap
#   jmap all process 
#################################

run_jmap()
{
  PIDNAME=$1
  PID=`find_process $PID_DIR/$PIDNAME.pid`
  if [[ -n "$PID" ]]; then
    if [ ! -d "$LOG_DIR/jmap" ]; then
      mkdir $LOG_DIR/jmap
    fi
    FILE=$LOG_DIR/jmap/jmap_${PIDNAME}_${PID}_`date '+%Y%m%d%H%M%S'`
    ${JAVA_HOME}/bin/jmap -dump:live,format=b,file=$FILE $PID 
  fi
}

#################################
# to_jmap_hist
#   jmap with histo option all process 
#################################

to_jmap_histo()
{
  for NAME in ${process[*]}; do
    control_$NAME jmap_histo
  done
}

#################################
# to_jmap
#   jmap all process 
#################################

run_jmap_histo()
{
  PIDNAME=$1
  PID=`find_process $PID_DIR/$PIDNAME.pid`
  if [[ -n "$PID" ]]; then
    if [ ! -d "$LOG_DIR/jmap" ]; then
      mkdir $LOG_DIR/jmap
    fi
    FILE=$LOG_DIR/jmap/jmap_${PIDNAME}_${PID}_`date '+%Y%m%d%H%M%S'`
    ${JAVA_HOME}/bin/jmap -histo:live $PID 1>$FILE 2>>$DEFAULT_LOG
  fi
}

#################################
# to_enable
#   Enable all disabled processes
#################################

to_enable()
{
  TARGET=$1
  if [ -z "$TARGET" ]; then
    for NAME in ${process[*]}; do
      enable_process $NAME
    done
  else
    enable_process $TARGET
  fi
}

enable_process()
{
  NAME=$1
  if [ -n "$NAME" ]; then
    DISABLED_FILE=$DISABLED_DIR/$NAME.lck
    if [ -e "$DISABLED_FILE" ]; then
      # remove lock file
      rm -f $DISABLED_FILE > /dev/null
    fi
  fi
}

#################################
# to_disable
#  Disable all processes
#################################

to_disable()
{
  TARGET=$1
  if [ -z "$TARGET" ]; then
    for NAME in ${process[*]}; do
      disable_process $NAME
    done
  else
    disable_process $TARGET
  fi
}

disable_process()
{
  NAME=$1
  if [ -n "$NAME" ]; then
    DISABLED_FILE=$DISABLED_DIR/$NAME.lck
    if [ -e "$DISABLED_FILE" ]; then
      echo "$NAME already disabled"
    else
      mkdir -p $DISABLED_DIR
      touch $DISABLED_FILE
    fi
  fi
}


#################################
# test set a lock file
# so only one instance
# of $CTL can run at at time.
# Report double instantiation failure
# and exit
#
# @param 1 reset [optional]
#################################

testSetLock()
{
  # if command is reset, clean the lock file, and exit
  if [[ "$COMMAND" == "reset" ]]; then
    resetLock
    exit 1
  fi


  if [[ -w "$LOCKFILE" ]]; then
    echo "Instance of "$CTL" already running command: " `cat $LOCKFILE`
    exit 1
  else
    touch $LOCKFILE
    echo $1 >> $LOCKFILE
  fi
}

clearLock()
{
  # remove the lock file if it exists
  if [[ -w "$LOCKFILE" ]]; then
    # remove lock file
    rm -f $LOCKFILE > /dev/null
  fi
}

# remove the lock file, don't check for existance
# or multiple instances.
resetLock()
{
  # force remove the lock file
  rm -f $LOCKFILE > /dev/null
}

#################################
# Project specific control blocks
#################################

#################################
# control_xxx
#
#    start/stop/status control
#    function for process
#
#    To use: create a control_xxx
#    for your process, providing
#   a start, stop, and status
#   routine.
#    Add process name to process[] array
#    in main.
#
#  @param $1 command - [start|stop|status]
#
#################################

# example
control_Example ()
{
  PROCESS_NAME=Example
  DISABLED_FILE=$DISABLED_DIR/${PROCESS_NAME}.lck

  case "$1" in
    'start')
      if [ -e "$DISABLED_FILE" ]; then
        echo "${PROCESS_NAME} disabled" 
      else
        # Application will send a startup alarm
        #${PROJECT_HOME}/bin/sendxlog 10858 CTL ${PROCESS_NAME} MESSAGE "MESSAGE,PARAMS"
        control_process start ${PROCESS_NAME} "START_COMMAND" "OPTIONS" $DEFAULT_LOG
      fi
    ;;

    'stop')
      # Application will send a shutdown alarm
      #${PROJECT_HOME}/bin/sendxlog 10857 CTL ${PROCESS_NAME} MESSAGE "MESSAGE,PARAMS"
      control_process stop ${PROCESS_NAME} "STOP_COMMAND" "OPTIONS" $DEFAULT_LOG
    ;;

    'status')
      PID=`find_process $PID_DIR/${PROCESS_NAME}.pid`
      if [[ -n "$PID" ]]; then
        if [[ "$2" = "verbose" ]]; then
          echo "${PROCESS_NAME}                               ACTIVE"
        else
          echo ACTIVE
        fi
      else
        if [ -e "$DISABLED_FILE" ]; then
          if [[ "$2" = "verbose" ]]; then
            echo "${PROCESS_NAME}                             DISABLED"
          else
            echo DISABLED
          fi
        elif [[ "$2" = "verbose" ]]; then
          echo "${PROCESS_NAME}                             INACTIVE"
        fi
      fi
    ;;

    'jmap')
      run_jmap ${PROCESS_NAME}
    ;;

    'jmap_histo')
      run_jmap_histo ${PROCESS_NAME}
    ;;
  esac
}

# Special control for XBUILD (Core) applications.
# Duplicate if you have to control more than one core.
# NOTE: that each core must run on a unique SOCKET_PORT else
# 'stop' will stop the wrong core.
control_XBUILD ()
{
  PROCESS_NAME=XBUILD
  DISABLED_FILE=$DISABLED_DIR/${PROCESS_NAME}.lck

  case "$1" in
    'start')
      if [ -e "$DISABLED_FILE" ]; then
        echo "${PROCESS_NAME} disabled" 
      else
        PID=`find_process $PID_DIR/${PROCESS_NAME}.pid`
        if [[ -z "$PID" ]]; then
          PID=`find_java_process ${PROJECT_HOME}`
        fi
        if [[ -n "$PID" ]]; then
          echo "${PROCESS_NAME} already running"
        else
          control_process start ${PROCESS_NAME} "$JAVA_BIN $JVM_ARGS $REDKNEE_MAINCLASS" "" $DEFAULT_LOG
  
          # Framework applications will send a startup alarm
          #${PROJECT_HOME}/bin/sendxlog 10858 CTL ${PROCESS_NAME} "" "${PROCESS_NAME}"
        fi
      fi
    ;;

    'stop')
            # PIDNAME is PROJECT_NAME
            # CMD is PROJECT_HOME
            # OPTIONS is SOCKET_PORT
      control_process stop.core ${PROCESS_NAME} "${PROJECT_HOME}" "${SOCKET_PORT}" $DEFAULT_LOG

      # Framework applications will send a shutdown alarm
      #${PROJECT_HOME}/bin/sendxlog 10857 CTL ${PROCESS_NAME} "" "${PROCESS_NAME}"
    ;;

    'status')
      PID=`find_process $PID_DIR/${PROCESS_NAME}.pid`
      if [[ -z "$PID" ]]; then
        PID=`find_java_process ${PROJECT_HOME}`
      fi
      if [[ -n "$PID" ]]; then
        if [[ "$2" = "verbose" ]]; then
          echo "${PROCESS_NAME}                                    ACTIVE"
        else
          echo ACTIVE
        fi
      else
        if [ -e "$DISABLED_FILE" ]; then
          if [[ "$2" = "verbose" ]]; then
            echo "${PROCESS_NAME}                                  DISABLED"
          else
            echo DISABLED
          fi
        elif [[ "$2" = "verbose" ]]; then
          echo "${PROCESS_NAME}                                  INACTIVE"
        fi
      fi
    ;;

    'jmap')
      run_jmap ${PROCESS_NAME}
    ;;

    'jmap_histo')
      run_jmap_histo ${PROCESS_NAME}
    ;;
  esac
}

#################################
# main
#################################

# ensure system in proper state
init

# process name list
# Create a control_xxx routine
# and add process name (xxx) to
# this array.
process[0]=XBUILD
#process[1]=EXAMPLE

# act on user request
case "$COMMAND" in

  'restart')
    to_stop
    sleep 2
    to_start
  ;;

  'pmon')
    to_pmon
  ;;

  'kill')
     force_kill
  ;;

  'threaddump')
     threaddump
  ;;

  'version')
    echo $version
  ;;

  'start')
  if [ -z $TARGET ]; then
    to_start
  else
    control_$TARGET start $ARGS
  fi
  ;;

  'stop')
    if [ -z $TARGET ]; then
      to_stop
    else
      control_$TARGET stop
    fi
  ;;

  'status')
    if [ -z $TARGET ]; then
      to_status
    else
      control_$TARGET status verbose
    fi
  ;;

  'stat')
    if [ -z $TARGET ]; then
      to_status
    else
      control_$TARGET status verbose
    fi
  ;;

  'debugstatus')
    if [ -z $TARGET ]; then
      to_debugstatus
    else
      control_$TARGET status verbose
    fi
  ;;

  'log_er')
    if [ -z $TARGET ]; then
      to_log_er
    else
      control_$TARGET log_er
    fi
  ;;

  'jmap')
    if [ -z $TARGET ]; then
      to_jmap
    else
      control_$TARGET jmap
    fi
  ;;

  'jmap_histo')
    if [ -z $TARGET ]; then
      to_jmap_histo
    else
      control_$TARGET jmap_histo
    fi
  ;;

  'enable')
    if [ -z $TARGET ]; then
      to_enable
    else
      to_enable $TARGET
    fi
  ;;

  'disable')
    if [ -z $TARGET ]; then
      to_disable
    else
      to_disable $TARGET
    fi
  ;;

  *) # DEFAULT
    $COMMAND
    echo "Usage: $0 start [-release x_x_x] [name] | stop [name] | restart | status | debugstatus | log_er | jmap | jmap_histo | threaddump | kill | version | enable | disable"
  ;;

esac

# we're done
#  NOTE: this will generate interrupt 0, which we trap
# the interrupt routine will remove the lock file
exit 0

# end

