p({"class": "foam.nanos.test.Test", "id": "Contact Tests", "description": "Tests related to contacts.", "server": false, "code": "/**\n * Tests for the Contacts feature.\n */\n\nrunTests();\n\nasync function runTests() {\n  var adminContext = x;\n\n  await resetTestData();\n  await Cannot_Create_Contact_Without_First_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_Long_First_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_First_Name_Containing_Number(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Without_Last_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_Long_Last_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_Last_Name_Containing_Number(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Without_Organization(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Without_Email(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Invalid_Email(adminContext);\n  await resetTestData();\n  await Cannot_Create_Second_Contact_With_Same_Email(adminContext);\n  await resetTestData();\n  await Can_Create_Contact(adminContext);\n  await resetTestData();\n  await Can_Update_Contact(adminContext);\n}\n\nasync function resetTestData() {\n  // Delete the test contacts.\n  await x.contactDAO\n    .where(foam.mlang.predicate.Eq.create({\n      arg1: net.nanopay.contacts.Contact.EMAIL,\n      arg2: 'devon@example.com'\n    }))\n    .removeAll_(x, 0, 1000, null, null);\n}\n\n/**\n * Utility method for tests that check if an error was thrown. \n */\nasync function Test_Throws(testText, expectedErrorMessage, fn) {\n  var threw = false;\n  var actualErrorMessage = '';\n  try {\n    await fn();\n  } catch(err) {\n    threw = true;\n    actualErrorMessage = err.message;\n  }\n  test(threw && actualErrorMessage === expectedErrorMessage, testText);\n  if ( threw && actualErrorMessage !== expectedErrorMessage ) {\n    print(`INFO: Expected to get '${expectedErrorMessage}' as the error message but got '${actualErrorMessage}' instead.`);\n  } else if ( ! threw  ) {\n    print(`INFO: Didn't throw an error.`);\n  }\n}\n\nasync function Cannot_Create_Contact_Without_First_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact without `firstName`, a required field.',\n    'First name is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Long_First_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact with a first name longer than 70 characters.',\n    'First name cannot exceed 70 characters.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_First_Name_Containing_Number(context) {\n  await Test_Throws(\n    'Cannot create a contact with a first name that contains a number.',\n    'First name cannot contain numbers.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: '5up3rm4n',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Last_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact without `lastName`, a required field.',\n    'Last name is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Long_Last_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact with a last name longer than 70 characters.',\n    'Last name cannot exceed 70 characters.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Last_Name_Containing_Number(context) {\n  await Test_Throws(\n    'Cannot create a contact with a last name that contains a number.',\n    'Last name cannot contain numbers.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: '5up3rm4n',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Organization(context) {\n  await Test_Throws(\n    'Cannot create a contact without `organization`, a required field.',\n    'Organization is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Email(context) {\n  await Test_Throws(\n    'Cannot create a contact without `email`, a required field.',\n    'Email is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Invalid_Email(context) {\n  await Test_Throws(\n    'Cannot create a contact with an empty string for an email address.',\n    'Email is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: '',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n  await Test_Throws(\n    'Cannot create a contact without anything before the @ in an email address.',\n    'Invalid email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: '@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n  await Test_Throws(\n    'Cannot create a contact with only a TLD in the email address.',\n    'Invalid email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Second_Contact_With_Same_Email(context) {\n  await Test_Throws(\n    'Cannot create two contacts with the same email address.',\n    'You already have a contact with that email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }));\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'OtherGuy',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Can_Create_Contact(context) {\n  var threw = false;\n  var result;\n  try {\n    result = await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n      email: 'devon@example.com',\n      firstName: 'Devon',\n      lastName: 'Carlyle',\n      organization: 'ExampleCo'\n    }));\n  } catch (err) {\n    threw = true;\n  }\n  var passed = ! threw &&\n    result.email === 'devon@example.com' &&\n    result.firstName === 'Devon' &&\n    result.lastName === 'Carlyle' &&\n    result.organization === 'ExampleCo';\n  test(passed, `User in '${context.user.group}' group can create a contact.`);\n}\n\nasync function Can_Update_Contact(context) {\n  var threw = false;\n  var result = await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n    email: 'devon@example.com',\n    firstName: 'Devon',\n    lastName: 'Carlyle',\n    organization: 'ExampleCo'\n  }));\n  try {\n    result.organization = 'Different';\n    result = await context.user.contacts.put(result);\n  } catch (err) {\n    threw = true;\n    print(err.message);\n  }\n  var passed = ! threw &&\n    result.email === 'devon@example.com' &&\n    result.firstName === 'Devon' &&\n    result.lastName === 'Carlyle' &&\n    result.organization === 'Different';\n  test(passed, `User in '${context.user.group}' group can update a contact.`);\n}\n"})
p({"class": "net.nanopay.contacts.AuthenticatedContactDAOTest", "id": "AuthenticatedContactDAOTest", "description": "Tests the functionality of the AuthenticatedContactDAO DAO decorator."})
p({class:"foam.nanos.test.Test",passed:14,id:"transactionFlow-User Payee with no BankAccount",lastRun:1543607413620,lastDuration:3243,code:"// This test is to confirm the flow for Ablii payments.\u000a//First the tests will show a flow where a User(payer) is paying an invoice to a User(payee) who does not have a BankAccount associated to them.\u000a// the flow is for an invoiceDAO decorator to set the destination Account of the invoice to the Digital Holding account (payers default digital Account) \u000a// status and balances are checked in the tests within *flow 1*.\u000a// * flow 1*:  After the money is kept sent to the digital account, there is a test (Test 4) that confirms \u000a// that the money in the holding Account is reserved for the payee of the invoice.\u000a// *flow 2*: Is to test the flow of Payer paying an invoice to Payee who is a Contact. A transaction is made to the payee, and tested to see if the funds \u000a// are stored correctly (holding account -payer's default digital account). Then this test mimics the onboarding of payee-Contact to payee-User and \u000a// then process funds to the payee's bank.\u000a// *flow 3* This flow is to test that a non-ablii/sme User(s) do not go through the same flow as described and tested above in flow 1 and flow 2.\u000a// *flow 4* We have tests that are to mimic the situation where a User(payer) begins to process a payment to a Contact or a User with no bank account (payee)\u000a// and then before the transaction has completed to the holding account where the invoiceStatus would become Pending_Acceptance, the Payee onboards \u000a// and adds a bank account. The verification of a bank account is the initial trigger to send money to the payee if any invoices are in holding. This is tested in \u000a// flow 5. Flow 4 tests the edge case where User onboards and one payment is IN_TRANSIT.\u000a\u000aimport foam.dao.ArraySink;\u000aimport foam.core.X;\u000aimport foam.mlang.predicate.*;\u000aimport foam.nanos.auth.User;\u000aimport foam.util.SafetyUtil;\u000aimport net.nanopay.contacts.Contact;\u000aimport net.nanopay.invoice.model.Invoice;\u000aimport net.nanopay.account.Account;\u000aimport net.nanopay.bank.CABankAccount;\u000aimport net.nanopay.account.DigitalAccount;\u000aimport net.nanopay.tx.model.Transaction;\u000aimport net.nanopay.tx.model.TransactionStatus;\u000aimport net.nanopay.bank.BankAccountStatus;\u000aimport net.nanopay.invoice.model.InvoiceStatus;\u000aimport net.nanopay.invoice.model.PaymentStatus;\u000aimport net.nanopay.cico.service.BankAccountVerifierService;\u000a\u000auser = x.get(\"user\");\u000auserDAO = x.get(\"localUserDAO\");\u000aaccountDAO = x.get(\"accountDAO\");\u000acontactDAO = x.get(\"contactDAO\");\u000ainvoiceDAO = x.get(\"invoiceDAO\");\u000a\u000a/* Whitelist the testing emails, then get rid of them at the end of the test. */\u000awhitelistedEmailDAO = x.get(\"whitelistedEmailDAO\");\u000aimport net.nanopay.auth.email.EmailWhitelistEntry;\u000awhitelistedEmailDAO.put(new EmailWhitelistEntry.Builder(x).setId(\"bob@marley.com\").build());\u000awhitelistedEmailDAO.put(new EmailWhitelistEntry.Builder(x).setId(\"oxy@moron.com\").build());\u000awhitelistedEmailDAO.put(new EmailWhitelistEntry.Builder(x).setId(\"unicorn@princess.com\").build());\u000awhitelistedEmailDAO.put(new EmailWhitelistEntry.Builder(x).setId(\"prince@caspen.com\").build());\u000awhitelistedEmailDAO.put(new EmailWhitelistEntry.Builder(x).setId(\"fox@example.com\").build());\u000awhitelistedEmailDAO.put(new EmailWhitelistEntry.Builder(x).setId(\"foo@bar.com\").build());\u000awhitelistedEmailDAO.put(new EmailWhitelistEntry.Builder(x).setId(\"bar@foo.com\").build());\u000a\u000a/* Confirm Clean UP */\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"bob@marley.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"oxy@moron.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"unicorn@princess.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"prince@caspen.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"fox@example.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"foo@bar.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"bar@foo.com\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account1\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account2\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account3\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account 4\")).removeAll();\u000acontactDAO.where(foam.mlang.MLang.EQ(Contact.EMAIL, \"fox@example.com\")).removeAll();\u000ainvoiceDAO.removeAll();\u000a\u000a/* Main User */\u000asmeUser = new User();\u000asmeUser.setGroup(\"smeBusinessAdmin\");\u000asmeUser.setFirstName(\"Unicorn\");\u000asmeUser.setLastName(\"Princess\");\u000asmeUser.setEmail(\"unicorn@princess.com\");\u000asmeUser.setEmailVerified(true);\u000a\u000asmeUser   = userDAO.put(smeUser);\u000aX smeUserContext = foam.util.Auth.sudo(x, smeUser);\u000atransactionDAO = smeUserContext.get(\"transactionDAO\").inX(smeUserContext);\u000a\u000a// FLOW 1 create test where User(smeUser) sends money via invoice1 to Ablii User(test1User)\u000a\u000a// Test User 1 \u000atest1User = new User();\u000atest1User.setGroup(\"smeBusinessAdmin\");\u000atest1User.setFirstName(\"Prince\");\u000atest1User.setLastName(\"Caspen\");\u000atest1User.setEmail(\"prince@caspen.com\");\u000atest1User.setEmailVerified(true);\u000a\u000atest1User = userDAO.put(test1User);\u000aX test1UserContext = foam.util.Auth.sudo(x, test1User);\u000atransactionDAO1 = test1UserContext.get(\"transactionDAO\").inX(test1UserContext);\u000a\u000a// bank account for smeUser\u000aaccount = new CABankAccount();\u000aaccount.setName(\"bank test account\");\u000aaccount.setDenomination(\"CAD\");\u000aaccount.setAccountNumber(\"12345678\");\u000aaccount.setInstitution(1);\u000aaccount.setBranchId(\"12345\");\u000aaccount.setStatus(BankAccountStatus.VERIFIED);\u000a\u000aaccount = smeUser.getAccounts(smeUserContext).put(account);\u000a\u000a// Create a payable invoice with the test1User as the payee.\u000ainvoice1Payable = new Invoice();\u000ainvoice1Payable.setPayeeId(test1User.getId());\u000ainvoice1Payable.setAmount(1);\u000ainvoice1Payable.setSourceCurrency(\"CAD\");\u000ainvoice1Payable.setDestinationCurrency(\"CAD\");\u000ainvoice1Payable.setAccount(account.getId());\u000ainvoice1Payable = smeUser.getExpenses(smeUserContext).put(invoice1Payable);\u000a\u000aAccount digAccount = (Account) accountDAO.find(invoice1Payable.getDestinationAccount());\u000a\u000a// TEST 1 : Was destination account correctly set?\u000atest(digAccount != null && digAccount instanceof DigitalAccount && digAccount.getOwner() == smeUser.getId() && invoice1Payable.getStatus() == InvoiceStatus.UNPAID, \"Test 1: User created Invoice dst account set to payer's default digitalAccount\");\u000a\u000a// Saving account balance for below test\u000apriorBalance = digAccount.findBalance(smeUserContext);\u000a\u000a// Pay the invoice.\u000atxn = new Transaction();\u000atxn.setPayeeId(test1User.getId());\u000atxn.setDestinationAccount(invoice1Payable.getDestinationAccount());\u000atxn.setInvoiceId(invoice1Payable.getId());\u000atxn.setAmount(invoice1Payable.getAmount());\u000atxn.setPayerId(smeUser.getId());\u000atxn.setSourceAccount(invoice1Payable.getAccount());\u000atxn = transactionDAO.put(txn);\u000a\u000ainvoice1Payable = smeUser.getExpenses(smeUserContext).find(invoice1Payable);\u000a\u000a// TEST 2 : Was status set correctly for an in progress Cashin from Bank to Digital.\u000atest(invoice1Payable.getStatus() == InvoiceStatus.IN_TRANSIT, \"Test 2: in-transit Status check - prior cashin to holding account\");\u000a\u000a\u000a// Update for test\u000atxn.setStatus(TransactionStatus.COMPLETED);\u000atxn = transactionDAO.put(txn);\u000atransferBalance = digAccount.findBalance(x);\u000ainvoice1Payable = smeUser.getExpenses(smeUserContext).find(invoice1Payable);\u000a\u000a// TEST 3: Is the status set correctly for a completed payment/transaction to Digital holding account? and does the account balance reflect the proper balance after a transaction\u000atest(invoice1Payable.getStatus() == InvoiceStatus.PENDING_ACCEPTANCE && (transferBalance - priorBalance) == invoice1Payable.getAmount(), \"Test 3: Invoice paid by moving money to payer's default digitalAccount\");\u000a\u000a// Testing whether we can withdraw money from Payer's DigitalAccount, arbitrarily.\u000aString errMsg = \"\";\u000atry{\u000a\u000atxn = new Transaction();\u000atxn.setPayeeId(smeUser.getId());\u000atxn.setSourceAccount(digAccount.getId());\u000atxn.setDestinationAccount(account.getId());\u000atxn.setAmount(invoice1Payable.getAmount());\u000atxn.setPayerId(smeUser.getId());\u000a\u000atxn = transactionDAO.put(txn);\u000a}catch(Exception e){\u000aerrMsg = e.toString();;\u000a}\u000a// TEST 4:  Is holding payment safe?\u000atest(errMsg.contains(\"Insufficient balance\") , \"Test 4: Can not withdraw money from Payer's DigitalAccount when a portion of balance is reserved in holding.\");\u000a\u000a// Mimic flow of depositing money that was sent to a User\u000a// User would see the invoice. If they click accept payment the below logic is executed\u000a// Difference is test1User.getId() would actually be user in current context and\u000a// account1 would be the chosen user account\u000a\u000a// For purpose of testing balance and status\u000ainvoice1Receivable = test1User.getSales(test1UserContext).find(invoice1Payable.getId());\u000a\u000a/* bank account for test1User */\u000aaccount1 = new CABankAccount();\u000aaccount1.setName(\"bank test account1\");\u000aaccount1.setDenomination(\"CAD\");\u000aaccount1.setAccountNumber(\"87654321\");\u000aaccount1.setInstitution(1);\u000aaccount1.setBranchId(\"54321\");\u000aaccount1.setStatus(BankAccountStatus.VERIFIED);\u000a\u000aaccount1 = test1User.getAccounts(test1UserContext).put(account1);\u000a\u000a// Info for below test\u000atransferBalance = digAccount.findBalance(x);\u000a\u000a// Receive funds - User accepts payment selecting account1 as dst account. \u000atxn1 = new Transaction();\u000atxn1.setSourceAccount(invoice1Receivable.getDestinationAccount());\u000atxn1.setDestinationAccount(account1.getId());\u000atxn1.setInvoiceId(invoice1Receivable.getId());\u000atxn1.setAmount(invoice1Receivable.getAmount());\u000a\u000atxn1 = transactionDAO1.put(txn1);\u000a\u000a// For purpose of testing balance and status\u000ainvoice1Receivable = test1User.getSales(test1UserContext).find(invoice1Receivable);\u000apaymentStatus = invoice1Receivable.getStatus();\u000atxn1.setStatus(TransactionStatus.COMPLETED);\u000atxn1 = transactionDAO.put(txn1);\u000a\u000a// TEST 5:  Is the status set correctly?\u000atest(paymentStatus == InvoiceStatus.DEPOSITING_MONEY && digAccount.findBalance(x) == 0, \"Test 5: Invoice paid by moving money from payer's default DigitalAccount to User who accepted payment\");\u000a\u000a\u000a// FLOW 2: create test where User(smeUser) sends money via invoice2 to an external Contact(test2Contact)\u000a\u000atest2Contact = new Contact();\u000atest2Contact.setEmail(\"fox@example.com\");\u000atest2Contact.setFirstName(\"Fox\");\u000atest2Contact.setLastName(\"McCloud\");\u000atest2Contact.setOrganization(\"Example Company\");\u000atest2Contact.setGroup(\"sme\");\u000a\u000atest2Contact = smeUser.getContacts(smeUserContext).put(test2Contact);\u000a\u000a// Create a payable invoice with the test2Contact as the payee.\u000ainvoice2Payable = new Invoice();\u000ainvoice2Payable.setPayeeId(test2Contact.getId());\u000ainvoice2Payable.setAmount(1);\u000ainvoice2Payable.setSourceCurrency(\"CAD\");\u000ainvoice2Payable.setDestinationCurrency(\"CAD\");\u000ainvoice2Payable.setAccount(account.getId());\u000a\u000ainvoice2Payable = smeUser.getExpenses(smeUserContext).put(invoice2Payable);\u000a\u000adigAccount2 = (Account) accountDAO.find(invoice2Payable.getDestinationAccount());\u000a\u000a// TEST 6:  Was destination account correctly set?\u000atest(digAccount2 != null && digAccount2 instanceof DigitalAccount && digAccount.getOwner() == smeUser.getId() && invoice2Payable.getStatus() == InvoiceStatus.UNPAID, \"Test 6: Ablii User created Invoice dst account set to payer's default DigitalAccount\");\u000a\u000a\u000a// Saving account balance for below test\u000apriorBalance = digAccount.findBalance(smeUserContext);\u000a\u000a// Pay the invoice.\u000atxn2 = new Transaction();\u000atxn2.setPayeeId(test2Contact.getId());\u000atxn2.setDestinationAccount(invoice2Payable.getDestinationAccount());\u000atxn2.setInvoiceId(invoice2Payable.getId());\u000atxn2.setAmount(invoice2Payable.getAmount());\u000atxn2.setPayerId(smeUser.getId());\u000atxn2.setSourceAccount(invoice2Payable.getAccount());\u000atxn2 = transactionDAO.put(txn2);\u000a// For purpose of testing balance\u000atxn2.setStatus(TransactionStatus.COMPLETED);\u000atxn2 = transactionDAO.put(txn2);\u000a\u000a// Update for test\u000atransferBalance = digAccount2.findBalance(x);\u000ainvoice2Payable = smeUser.getExpenses(smeUserContext).find(invoice2Payable);\u000a\u000a// TEST 7: Invoice to Contact was paid and Completed. Is the InvoiceStatus set correctly?\u000atest(invoice2Payable.getStatus() == InvoiceStatus.PENDING_ACCEPTANCE && (transferBalance - priorBalance) == invoice2Payable.getAmount(), \"Test 7: Invoice paid by moving money to payer's default DigitalAccount\");\u000a\u000a// Mimic flow for Contact becoming User\u000atest3User = new User();\u000atest3User.setGroup(\"smeBusinessAdmin\");\u000atest3User.setFirstName(\"Fox\");\u000atest3User.setLastName(\"MkCloud\");\u000atest3User.setEmail(\"fox@example.com\");\u000atest3User.setEmailVerified(true);\u000a\u000atest3User = userDAO.put(test3User);\u000aX test3UserContext = foam.util.Auth.sudo(x, test3User);\u000atransactionDAO2 = test3UserContext.get(\"transactionDAO\").inX(test3UserContext);\u000a\u000a// Note: test3User.getSales(test3UserContext).find(invoice2Payable.getId()) = null, \u000a// because this test is not linking invoices of contacts to their equivalent user. \u000a// This feature is reserved for the onboarding of a contact.\u000a// Below a put into the invoiceDAO will mimic the onboarding of a Contact - a SMEInvoiceDAO decorator will set things right\u000ainvoice2Receivable = test3User.getSales(test3UserContext).put(invoice2Payable);\u000a\u000a// Test 8: Contact on Boards to User(test3User), has the invoice payee been changed?\u000atest(invoice2Receivable.getPayeeId() == test3User.getId(), \"Test 8: testing whether the invoice PayeeId is updated in a put to the invoiceDAO test3User.getId() = \" + test3User.getId() + \" invoice2Receivable.getPayeeId() \" + invoice2Receivable.getPayeeId());\u000a\u000a/* bank account for test3User */\u000aaccount2 = new CABankAccount();\u000aaccount2.setName(\"bank test account2\");\u000aaccount2.setDenomination(\"CAD\");\u000aaccount2.setAccountNumber(\"87654300\");\u000aaccount2.setInstitution(1);\u000aaccount2.setBranchId(\"54300\");\u000aaccount2.setStatus(BankAccountStatus.VERIFIED);\u000a\u000aaccount2 = test3User.getAccounts(test3UserContext).put(account2);\u000a\u000a// Info for below test\u000adigAccount = (Account) accountDAO.find(invoice2Receivable.getDestinationAccount());\u000atransferBalance = digAccount.findBalance(x);\u000a\u000a// Receive funds - User accepts payment selecting account1 as dst account. \u000atxn3 = new Transaction();\u000atxn3.setSourceAccount(invoice2Receivable.getDestinationAccount());\u000atxn3.setDestinationAccount(account2.getId());\u000atxn3.setInvoiceId(invoice2Receivable.getId());\u000atxn3.setAmount(invoice2Receivable.getAmount());\u000atxn3 = transactionDAO2.put(txn3);\u000a\u000a// Updates: For purpose of testing balance and status\u000ainvoice2Receivable = test3User.getSales(test3UserContext).find(invoice2Receivable);\u000apaymentStatus = invoice2Receivable.getStatus();\u000atxn3.setStatus(TransactionStatus.COMPLETED);\u000atxn3 = transactionDAO.put(txn3);\u000a\u000a// TEST 9: test3User adds a bank account and a transaction is made to send money to correct owner of funds(test3User). Was this done correctly?\u000atest(paymentStatus == InvoiceStatus.DEPOSITING_MONEY && digAccount.findBalance(smeUserContext) == 0, \"Test 9: Invoice paid by moving money from payer's default DigitalAccount\");\u000a\u000a// FLOW 3: create test to confirm a non-ablii/sme user does not go through the holding account flow\u000a\u000a// Mimic flow for Contact becoming User\u000atest4User = new User();\u000atest4User.setFirstName(\"Fo\");\u000atest4User.setLastName(\"Bar\");\u000atest4User.setEmail(\"foo@bar.com\");\u000atest4User.setEmailVerified(true);\u000a\u000a// Mimic flow for Contact becoming User\u000atest5User = new User();\u000atest5User.setFirstName(\"BAR\");\u000atest5User.setLastName(\"Foo\");\u000atest5User.setEmail(\"bar@foo.com\");\u000atest5User.setEmailVerified(true);\u000a\u000atest4User = userDAO.put(test4User);\u000atest5User = userDAO.put(test5User);\u000aX test4UserContext = foam.util.Auth.sudo(x, test4User);\u000atransactionDAO3 = test4UserContext.get(\"transactionDAO\").inX(test4UserContext);\u000a\u000a/* bank account for test3User */\u000aaccount3 = new CABankAccount();\u000aaccount3.setName(\"bank test account3\");\u000aaccount3.setDenomination(\"CAD\");\u000aaccount3.setAccountNumber(\"87654300\");\u000aaccount3.setInstitution(1);\u000aaccount3.setBranchId(\"54300\");\u000aaccount3.setStatus(BankAccountStatus.VERIFIED);\u000a\u000aaccount3 = test4User.getAccounts(test4UserContext).put(account3);\u000a\u000ainvoice0 = new Invoice();\u000ainvoice0.setPayeeId(test5User.getId());\u000ainvoice0.setAmount(1);\u000ainvoice0.setDestinationCurrency(\"CAD\");\u000ainvoice0.setAccount(account.getId());\u000ainvoice0 = test4User.getExpenses(test4UserContext).put(invoice0);\u000a\u000a// Basic Trans\u000atxn4 = new Transaction();\u000atxn4.setSourceAccount(account3.getId());\u000atxn4.setInvoiceId(invoice0.getId());\u000atxn4.setAmount(1);\u000atxn4 = transactionDAO3.put(txn4);\u000a\u000ainvoice0 = (Invoice)test4User.getExpenses(test4UserContext).find(invoice0.getId());\u000a// TEST 10: non-ablii/sme user will not follow the above tested transaction flow?\u000atest(invoice0.getStatus() != InvoiceStatus.PENDING_ACCEPTANCE, \"Test 10: Confirm a non-ablii/sme user will not follow the above tested transaction flow. InvoiceStatus: \" + invoice0.getStatus() + \" payee = \"+invoice0.getPayeeId() + \" payer = \" + invoice0.getPayerId() );\u000a\u000a// FLOW 4: Auto deposit while payment IN_TRANSIT\u000a\u000a/* For test */\u000a// Test User 6 \u000atest6User = new User();\u000atest6User.setGroup(\"smeBusinessAdmin\");\u000atest6User.setFirstName(\"Warrior\");\u000atest6User.setLastName(\"Wizard\");\u000atest6User.setEmail(\"oxy@moron.com\");\u000atest6User.setEmailVerified(true);\u000a\u000atest6User = userDAO.put(test6User);\u000aX test6UserContext = foam.util.Auth.sudo(x, test6User);\u000atransactionDAO4 = test1UserContext.get(\"transactionDAO\").inX(test6UserContext);\u000a\u000a// Create a payable invoice with the test1User as the payee.\u000ainvoice1 = new Invoice();\u000ainvoice1.setPayeeId(test6User.getId());\u000ainvoice1.setAmount(1);\u000ainvoice1.setSourceCurrency(\"CAD\");\u000ainvoice1.setDestinationCurrency(\"CAD\");\u000ainvoice1.setAccount(account.getId());\u000ainvoice1 = smeUser.getExpenses(smeUserContext).put(invoice1);\u000a\u000a// destination Account should be set to holding account( payer's default digital account)\u000a\u000a// Pay the invoice.\u000atxn = new Transaction();\u000atxn.setPayerId(smeUser.getId());\u000atxn.setPayeeId(test6User.getId());\u000atxn.setDestinationAccount(invoice1.getDestinationAccount());\u000atxn.setInvoiceId(invoice1.getId());\u000atxn.setAmount(invoice1.getAmount());\u000atxn.setPayerId(smeUser.getId());\u000atxn.setSourceAccount(invoice1.getAccount());\u000atxn = transactionDAO.put(txn);\u000a\u000a// prior completion of the Cashin to the holding account( payer's default digital account) the User adds a verified bank account\u000a\u000a// bank account for test6User\u000aaccount4 = new CABankAccount();\u000aaccount4.setName(\"bank test account 4\");\u000aaccount4.setDenomination(\"CAD\");\u000aaccount4.setAccountNumber(\"12345678\");\u000aaccount4.setInstitution(1);\u000aaccount4.setBranchId(\"12345\");\u000aaccount4.setIsDefault(true);\u000aaccount4.setStatus(BankAccountStatus.VERIFIED);\u000a\u000aaccount4 = test6User.getAccounts(test6UserContext).put(account4);\u000a\u000a// TEST 11 : Is the status what we expect for an inprogress Cashin from Bank to Digital.\u000ainvoice1 = smeUser.getExpenses(smeUserContext).find(invoice1);\u000atest(invoice1.getStatus() == InvoiceStatus.IN_TRANSIT, \"Test 11: in-transit Status check - prior cashin to holding account\");\u000a\u000a// Update for test\u000atxn.setStatus(TransactionStatus.COMPLETED);\u000atxn = transactionDAO.put(txn);\u000ainvoice1 = smeUser.getExpenses(smeUserContext).find(invoice1);\u000a\u000a// TEST 12: Is the status set correctly to reflect the initiation of the auto deposit to payee's actual bank account\u000atest(invoice1.getStatus() == InvoiceStatus.DEPOSITING_MONEY, \"Test 12: Does the status set correctly to reflect the initiation of the auto deposit to payee's actual bank account\");\u000a\u000a//flow 5: Auto deposit with user adding a bank account\u000a\u000atest7User = new User();\u000atest7User.setGroup(\"smeBusinessAdmin\");\u000atest7User.setFirstName(\"War\");\u000atest7User.setLastName(\"Zone\");\u000atest7User.setEmail(\"bob@marley.com\");\u000atest7User.setEmailVerified(true);\u000a\u000atest7User = userDAO.put(test7User);\u000aX test7UserContext = foam.util.Auth.sudo(x, test7User);\u000atransactionDAO7 = test7UserContext.get(\"transactionDAO\").inX(test7UserContext);\u000a\u000a// Create a payable invoice with the test7User as the payee.\u000ainvoice2 = new Invoice();\u000ainvoice2.setPayeeId(test7User.getId());\u000ainvoice2.setAmount(1);\u000ainvoice2.setSourceCurrency(\"CAD\");\u000ainvoice2.setDestinationCurrency(\"CAD\");\u000ainvoice2.setAccount(account.getId());\u000ainvoice2 = smeUser.getExpenses(smeUserContext).put(invoice2);\u000a\u000a// destination Account should be set to holding account( payer's default digital account)\u000a\u000a// Pay the invoice.\u000atxn00 = new Transaction();\u000atxn00.setPayerId(smeUser.getId());\u000atxn00.setPayeeId(test6User.getId());\u000atxn00.setDestinationAccount(invoice2.getDestinationAccount());\u000atxn00.setInvoiceId(invoice2.getId());\u000atxn00.setAmount(invoice2.getAmount());\u000atxn00.setPayerId(smeUser.getId());\u000atxn00.setSourceAccount(invoice2.getAccount());\u000atxn00 = transactionDAO.put(txn00);\u000atxn00.setStatus(TransactionStatus.COMPLETED);\u000atxn00 = transactionDAO.put(txn00);\u000a\u000a// bank account for test7User\u000aaccount5 = new CABankAccount();\u000aaccount5.setName(\"bank test account 5\");\u000aaccount5.setDenomination(\"CAD\");\u000aaccount5.setAccountNumber(\"12345688\");\u000aaccount5.setInstitution(1);\u000aaccount5.setBranchId(\"12545\");\u000aaccount5.setIsDefault(true);\u000aaccount5.setStatus(BankAccountStatus.VERIFIED);\u000a\u000aaccount5 = test7User.getAccounts(test7UserContext).put(account5);\u000a\u000a// TEST 13: Is the status what we expect for funds in holding Digital.\u000ainvoice2 = smeUser.getExpenses(smeUserContext).find(invoice2);\u000atest(invoice2.getStatus() == InvoiceStatus.PENDING_ACCEPTANCE, \"Test 13: Status check\");\u000a\u000abankAccVer = (BankAccountVerifierService) test7UserContext.get(\"bankAccountVerification\");\u000abankAccVer.verify(test7UserContext, account5.getId(), -1000000);\u000a\u000ainvoice2 = smeUser.getExpenses(smeUserContext).find(invoice2);\u000a\u000a// TEST 14: Is the status set correctly to reflect the initiation of the auto deposit to payee's actual bank account\u000atest(invoice2.getStatus() == InvoiceStatus.DEPOSITING_MONEY, \"Test 14: Does the status set correctly to reflect the initiation of the auto deposit to payee's actual bank account\");\u000a\u000a/* Clean UP */\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"bob@marley.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"oxy@moron.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"unicorn@princess.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"prince@caspen.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"fox@example.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"foo@bar.com\")).removeAll();\u000auserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"bar@foo.com\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account1\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account2\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account3\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account 4\")).removeAll();\u000aaccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"bank test account 5\")).removeAll();\u000acontactDAO.where(foam.mlang.MLang.EQ(Contact.EMAIL, \"fox@example.com\")).removeAll();\u000ainvoiceDAO.where(foam.mlang.MLang.EQ(Invoice.ID, invoice1Payable.getId())).removeAll();\u000ainvoiceDAO.where(foam.mlang.MLang.EQ(Invoice.ID, invoice1Receivable.getId())).removeAll();\u000ainvoiceDAO.where(foam.mlang.MLang.EQ(Invoice.ID, invoice2Payable.getId())).removeAll();\u000ainvoiceDAO.where(foam.mlang.MLang.EQ(Invoice.ID, invoice2Receivable.getId())).removeAll();\u000awhitelistedEmailDAO.remove(new EmailWhitelistEntry.Builder(x).setId(\"bob@marley.com\").build());\u000awhitelistedEmailDAO.remove(new EmailWhitelistEntry.Builder(x).setId(\"oxy@moron.com\").build());\u000awhitelistedEmailDAO.remove(new EmailWhitelistEntry.Builder(x).setId(\"unicorn@princess.com\").build());\u000awhitelistedEmailDAO.remove(new EmailWhitelistEntry.Builder(x).setId(\"prince@caspen.com\").build());\u000awhitelistedEmailDAO.remove(new EmailWhitelistEntry.Builder(x).setId(\"fox@example.com\").build());\u000awhitelistedEmailDAO.remove(new EmailWhitelistEntry.Builder(x).setId(\"foo@bar.com\").build());\u000awhitelistedEmailDAO.remove(new EmailWhitelistEntry.Builder(x).setId(\"bar@foo.com\").build());",output:"SUCCESS: Test 1: User created Invoice dst account set to payer's default digitalAccount\u000aSUCCESS: Test 2: in-transit Status check - prior cashin to holding account\u000aSUCCESS: Test 3: Invoice paid by moving money to payer's default digitalAccount\u000aSUCCESS: Test 4: Can not withdraw money from Payer's DigitalAccount when a portion of balance is reserved in holding.\u000aSUCCESS: Test 5: Invoice paid by moving money from payer's default DigitalAccount to User who accepted payment\u000aSUCCESS: Test 6: Ablii User created Invoice dst account set to payer's default DigitalAccount\u000aSUCCESS: Test 7: Invoice paid by moving money to payer's default DigitalAccount\u000aSUCCESS: Test 8: testing whether the invoice PayeeId is updated in a put to the invoiceDAO test3User.getId() = 8011 invoice2Receivable.getPayeeId() 8011\u000aSUCCESS: Test 9: Invoice paid by moving money from payer's default DigitalAccount\u000aSUCCESS: Test 10: Confirm a non-ablii/sme user will not follow the above tested transaction flow. InvoiceStatus: PENDING_APPROVAL payee = 8013 payer = 8012\u000aSUCCESS: Test 11: in-transit Status check - prior cashin to holding account\u000aSUCCESS: Test 12: Does the status set correctly to reflect the initiation of the auto deposit to payee's actual bank account\u000aSUCCESS: Test 13: Status check\u000aSUCCESS: Test 14: Does the status set correctly to reflect the initiation of the auto deposit to payee's actual bank account\u000a"})
p({"class":"net.nanopay.contacts.AbliiFlowTests","id":"AbliiFlowTests"})
