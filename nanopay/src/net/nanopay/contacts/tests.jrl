p({"class":"foam.nanos.test.Test","passed":11,"id":"Contact Tests","description":"Tests related to contacts.","lastRun":"2018-08-30T19:16:32.436Z","lastDuration":1759,"server":false,"code":"/**\n * Tests for the Contacts feature.\n */\n\nrunTests();\n\nasync function runTests() {\n  // var adminContext = x;\n  // var nonAdminUser = await resetTestData();\n  // var nonAdminContext = x.createSubContext({ user: nonAdminUser });\n  // await Cannot_Create_Contact_Without_First_Name(adminContext);\n  // await Cannot_Create_Contact_Without_First_Name(nonAdminContext);\n  await Cannot_Create_Contact_Without_First_Name(x);\n  await Cannot_Create_Contact_With_Long_First_Name(x);\n  await Cannot_Create_Contact_With_First_Name_Containing_Number(x);\n  await Cannot_Create_Contact_Without_Last_Name(x);\n  await Cannot_Create_Contact_With_Long_Last_Name(x);\n  await Cannot_Create_Contact_With_Last_Name_Containing_Number(x);\n  await Cannot_Create_Contact_Without_Organization(x);\n  await Cannot_Create_Contact_Without_Email(x);\n  await Cannot_Create_Contact_Invalid_Email(x);\n}\n\nasync function resetTestData() {\n  // Delete the test user.\n  await x.userDAO\n    .where(foam.mlang.predicate.Eq.create({\n      arg1: foam.nanos.auth.User.EMAIL,\n      arg2: 'nonadmin@example.com'\n    }))\n    .removeAll_(x, 0, 1000, null, null);\n  // Delete the test contacts.\n  await x.contactDAO\n    .where(foam.mlang.predicate.Eq.create({\n      arg1: net.nanopay.contacts.Contact.EMAIL,\n      arg2: 'devon@example.com'\n    }))\n    .removeAll_(x, 0, 1000, null, null);\n  var nonAdminUser = foam.nanos.auth.User.create({\n    email: 'nonadmin@example.com',\n    group: 'business',\n    type: 'Business'\n  });\n  await x.userDAO.put(nonAdminUser);\n  return nonAdminUser;\n}\n\n/**\n * Utility method for tests that check if an error was thrown. \n */\nasync function Test_Throws(testText, expectedErrorMessage, fn) {\n  await resetTestData();\n  var threw = false;\n  var actualErrorMessage = '';\n  try {\n    await fn();\n  } catch(err) {\n    threw = true;\n    actualErrorMessage = err.message;\n  }\n  var passed = threw && actualErrorMessage === expectedErrorMessage;\n  test(passed, testText);\n  if ( ! passed ) print(`Expected to get '${expectedErrorMessage}' as the error message but got '${actualErrorMessage}' instead.`);\n}\n\nasync function Cannot_Create_Contact_Without_First_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact without `firstName`, a required field.',\n    'First name is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Long_First_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact with a first name longer than 70 characters.',\n    'First name cannot exceed 70 characters.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_First_Name_Containing_Number(context) {\n  await Test_Throws(\n    'Cannot create a contact with a first name that contains a number.',\n    'First name cannot contain numbers.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: '5up3rm4n',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Last_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact without `lastName`, a required field.',\n    'Last name is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Long_Last_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact with a last name longer than 70 characters.',\n    'Last name cannot exceed 70 characters.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Last_Name_Containing_Number(context) {\n  await Test_Throws(\n    'Cannot create a contact with a last name that contains a number.',\n    'Last name cannot contain numbers.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: '5up3rm4n',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Organization(context) {\n  await Test_Throws(\n    'Cannot create a contact without `organization`, a required field.',\n    'Organization is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Email(context) {\n  await Test_Throws(\n    'Cannot create a contact without `email`, a required field.',\n    'Email is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Invalid_Email(context) {\n  await Test_Throws(\n    'Cannot create a contact with an empty string for an email address.',\n    'Email is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: '',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n  await Test_Throws(\n    'Cannot create a contact without anything before the @ in an email address.',\n    'Invalid email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: '@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n  await Test_Throws(\n    'Cannot create a contact with only a TLD in the email address.',\n    'Invalid email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n","output":"SUCCESS: Cannot create a contact without `firstName`, a required field.\nSUCCESS: Cannot create a contact with a first name longer than 70 characters.\nSUCCESS: Cannot create a contact with a first name that contains a number.\nSUCCESS: Cannot create a contact without `lastName`, a required field.\nSUCCESS: Cannot create a contact with a last name longer than 70 characters.\nSUCCESS: Cannot create a contact with a last name that contains a number.\nSUCCESS: Cannot create a contact without `organization`, a required field.\nSUCCESS: Cannot create a contact without `email`, a required field.\nSUCCESS: Cannot create a contact with an empty string for an email address.\nSUCCESS: Cannot create a contact without anything before the @ in an email address.\nSUCCESS: Cannot create a contact with only a TLD in the email address.\n"})
p({"class":"foam.nanos.test.Test","id":"Holding Account Test","code":"import foam.dao.ArraySink;\nimport foam.mlang.predicate.*;\nimport net.nanopay.contacts.Contact;\nimport net.nanopay.invoice.model.Invoice;\nimport net.nanopay.account.Account;\nimport net.nanopay.bank.CABankAccount;\nimport net.nanopay.account.HoldingAccount;\nimport net.nanopay.tx.model.Transaction;\nimport net.nanopay.tx.TransactionType;\nimport net.nanopay.tx.model.TransactionStatus;\nimport net.nanopay.bank.BankAccountStatus;\n\nuser = x.get(\"user\");\naccountDAO = x.get(\"accountDAO\");\ncontactDAO = x.get(\"contactDAO\");\ntransactionDAO = x.get(\"transactionDAO\");\n\n// Try to remove the existing source bank account if there is one.\naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"Holding account test account\")).removeAll();\n\n// Create the test bank account to send money from.\naccount = new CABankAccount();\naccount.setName(\"Holding account test account\");\naccount.setDenomination(\"CAD\");\naccount.setAccountNumber(\"12345678\");\naccount.setInstitution(1);\naccount.setBranchId(\"12345\");\naccount.setStatus(BankAccountStatus.VERIFIED);\naccount = user.getAccounts(x).put(account);\n\n// Try to remove the existing contact if there is one.\ncontactDAO.where(foam.mlang.MLang.EQ(Contact.EMAIL, \"fox@example.com\")).removeAll();\n\n// Create the test contact to send money to.\ncontact = new Contact();\ncontact.setEmail(\"fox@example.com\");\ncontact.setFirstName(\"Fox\");\ncontact.setLastName(\"McCloud\");\ncontact.setOrganization(\"Example Company\");\nfox = user.getContacts(x).put(contact);\n\n// Try to remove the existing holding account if there is one.\naccountDAO.where(foam.mlang.MLang.INSTANCE_OF(HoldingAccount.class)).removeAll();\n\n// Create a payable invoice with the contact as the payee.\ninvoice = new Invoice();\ninvoice.setPayeeId(fox.getId());\ninvoice.setAmount(1);\ninvoice.setDestinationCurrency(\"CAD\");\ninvoice = user.getExpenses(x).put(invoice);\n\n// Check that the holding account was created.\nPredicate[] predicates = new Predicate[2];\npredicates[0] = foam.mlang.MLang.INSTANCE_OF(HoldingAccount.class);\npredicates[1] = foam.mlang.MLang.EQ(HoldingAccount.INVOICE_ID, invoice.getId());\nquery = new And(predicates);\nholdingAccounts = accountDAO.where(query).select().getArray();\ntest(holdingAccounts.size() == 1, \"A holding account was created for the invoice.\");\nHoldingAccount holdingAccount;\nif ( holdingAccounts.size() > 0 ) {\n  holdingAccount = holdingAccounts.get(0);\n} else {\n  print(\"DEBUG: holdingAccounts.size() = \" + holdingAccounts.size().toString());\n}\n\n// Pay the invoice.\ntxn = new Transaction();\ntxn.setPayeeId(fox.getId());\ntxn.setDestinationAccount(holdingAccount.getId());\ntxn.setInvoiceId(invoice.getId());\ntxn.setAmount(invoice.getAmount());\ntxn.setPayerId(user.getId());\ntxn.setSourceAccount(account.getId());\ntxn.setType(TransactionType.CASHIN);\ntxn = transactionDAO.put(txn);\ntxn.setStatus(TransactionStatus.COMPLETED);\ntxn = transactionDAO.put(txn);\n\n// Check that the money moved to the holding account.\nholdingAccount = accountDAO.find(holdingAccount.getId());\ntest(holdingAccount.findBalance(x) == 1, \"Money was moved to the holding account.\");\n"})