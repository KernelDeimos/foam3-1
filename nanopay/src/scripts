p({"class":"foam.nanos.script.Script","id":"createInvoices","description":"Create Test Data","server":false,"scheduled":false,"code":" var MS_PER_DAY = 1000 * 3600 * 24;\nvar invoiceDAO = x.invoiceDAO;\n\nthis.__context__.userDAO.select().then(function (bs) {\nvar l = bs.array.length;\nfor ( var i = 0 ; i < 1000 ; i++ ) {\nvar fi = Math.floor(Math.random()*l);\nvar ti = Math.floor(Math.random()*l);\nvar dd = new Date(Date.now() - 2*360*MS_PER_DAY*(Math.random()-0.1));\nvar amount = Math.floor(Math.pow(10,3+Math.random()*4))/100;\n\nif ( ti === fi ) continue;\nvar inv = net.nanopay.invoice.model.Invoice.create({\ndraft:            Math.random()<0.002,\ninvoiceNumber:    10000+i,\npurchaseOrder:    10000+i,\npayerId:   bs.array[fi].id,\npayeeId:   bs.array[ti].id,\n// fromBusinessName: bs.array[fi-100].name,\n// toBusinessName:   bs.array[ti-100].name,\ndueDate:        dd,\namount:           amount\n},x);\n\nif ( Math.random() < 0.005 ) {\ninv.paymentId = -1;\n} else if ( Math.random() < 0.97 ) {\ninv.paymentDate = new Date(inv.dueDate.getTime() - ( 7 + Math.random() * 60 ) * MS_PER_DAY);\nif ( inv.paymentDate < Date.now() ) {\ninv.paymentId = inv.invoiceNumber;\n}\n}\n\nconsole.log(inv.stringify());\ninvoiceDAO.put(inv);\n}\n\n});","output":"","notes":""})
p({"class":"foam.nanos.script.Script","id":"createUsers","enabled":false,"description":"Create test Users","lastDuration":0,"server":false,"scheduled":false,"code":"var lastNames = [\n'Martin',\n'Jacobs',\n'Yang',\n'Smith',\n'Johnson',\n'Williams',\n'Jones',\n'Brown',\n'Davis',\n'Miller',\n'Wilson',\n'Moore',\n'Taylor',\n'Anderson',\n'Thomas',\n'Jackson',\n'White',\n'Harris',\n'Martin',\n'Thompson',\n'Garcia',\n'Martinez',\n'Robinson',\n'Clark',\n'Rodrigues',\n'Lewis',\n'Lee',\n'Walker',\n'Hall',\n'Allen',\n'Young',\n'Hernandez',\n'King',\n'Wright',\n'Lopez',\n'Hill',\n'Scott',\n'Green',\n'Adams',\n'Baker',\n'Gonzalez',\n'Nelson',\n'Carter',\n'Mitchell',\n'Perez',\n'Roberts',\n'Turner',\n'Phillips',\n'Campbell',\n'Parker',\n'Evans',\n'Edwards',\n'Collins',\n'Stewart',\n'Sanchez',\n'Morris',\n'Rogers',\n'Reed',\n'Cook',\n'Morgan',\n'Bell',\n'Murphy',\n'Bailey',\n'Rivera',\n'Cooper',\n'Richardson',\n'Cox',\n'Howard',\n'Ward',\n'Torres',\n'Peterson',\n'Gray',\n'Ramirez',\n'James',\n'Watson',\n'Brooks',\n'Kelly',\n'Sanders',\n'Price',\n'Bennett',\n'Wood'\n];\nvar firstNames = [\n'Ricky',\n'Sophia',\n'Jian',\n'Jackson',\n'Emma',\n'Aiden',\n'Olivia',\n'Lucas',\n'Ava',\n'Liam',\n'Mia',\n'Noah',\n'Isabella',\n'Ethan',\n'Riley',\n'Mason',\n'Aria',\n'Caden',\n'Zoe',\n'Oliver',\n'Charlotte',\n'Elijah',\n'Lily',\n'Grayson',\n'Layla',\n'Jacob',\n'Amelia',\n'Michael',\n'Emily',\n'Benjamin',\n'Madelyn',\n'Carter',\n'Aubrey',\n'James',\n'Adalyn',\n'Jayden',\n'Madison',\n'Alexander',\n'Harper',\n'Caleb',\n'Abigail',\n'Ryan',\n'Aaliyah',\n'Luke',\n'Avery',\n'Daniel',\n'Evelyn',\n'Jack',\n'Kaylee',\n'William',\n'Ella',\n'Owen',\n'Ellie',\n'Gabriel',\n'Scarlett',\n'Matthew',\n'Arianna',\n'Connor',\n'Hailey',\n'Jayce',\n'Nora',\n'Isaac',\n'Addison',\n'Sebastian',\n'Brooklyn',\n'Henry',\n'Hannah',\n'Muhammad',\n'Mila',\n'Cameron',\n'Leah',\n'Wyatt',\n'Elizabeth',\n'Dylan',\n'Sarah',\n'Nathan',\n'Eliana',\n'Nicholas'\n];\n\n\n[\n'AAA CAD Business',\n'ABC Engineering',\n'Ali Designs',\n'Betasoloin',\n'Betatech',\n'Bioholding',\n'Bioplex',\n'Blackzim',\n'Cancity',\n'Codehow',\n'Condax',\n'Conecom',\n'Dalttechnology',\n'dambase',\n'Domzoom',\n'Doncon',\n'Donquadtech',\n'Dontechi',\n'Donware',\n'Fasehatice',\n'Faxquote',\n'Finhigh',\n'Finjob',\n'Funholding',\n'Ganjaflex',\n'Gogozoom',\n'Golddex',\n'Goodsilron',\n'Green-Plus',\n'Groovestreet',\n'Hatfan',\n'Hottechi',\n'Inity',\n'Isdom',\n'Iselectrics',\n'J-Texon',\n'Kan-code',\n'Kinnamplus',\n'Konex',\n'Konmatfix',\n'Labdrill',\n'Lexiqvolax',\n'Mathtouch',\n'Nam-zim',\n'Newex',\n'Ontomedia',\n'Openlane',\n'Opentech',\n'Plexzap',\n'Plusstrip',\n'Plussunin',\n'Rangreen',\n'Rantouch',\n'Ron-tech',\n'Rundofase',\n'Scotfind',\n'Scottech',\n'Silis',\n'Singletechno',\n'Sonron',\n'Stanredtax',\n'Statholdings',\n'Streethex',\n'Sumace',\n'Sunnamplex',\n'Toughzap',\n'Treequote',\n'Warephase',\n'Xx-holding',\n'Xx-zobam',\n'Y-corporation',\n'year-job',\n'Yearin',\n'Zathunicon',\n'Zencorporation',\n'Zoomit',\n'Zotware',\n'Zumgoity'\n].forEach(function (name, i) {\nvar user = foam.nanos.auth.User.create({ id: 100+i, group: 'shopper', organization: name, verifiedEmail: true, firstName: firstNames[i], lastName: lastNames[i], email: 'person' + i + '@nanopay.net'});\nconsole.log(user.stringify());\nx.userDAO.put(user);\n})\n","output":"","notes":""})
p({"class":"foam.nanos.script.Script","id":"createOneUserPerGroup","description":"Create one sample user per group for testing purposes.","lastRun":"2017-12-03T18:00:46.805Z","server":true,"scheduled":false,"code":"import foam.nanos.auth.*;\n\nuserDAO = x.get(\"userDAO\");\ngroupDAO = x.get(\"groupDAO\");\n\ngroups = groupDAO.select().getArray();\n\nfor ( i = 0 ; i < groups.size() ; i++ ) {\ngroup = groups.get(i);\nuser = new User();\nuser.setGroup(group.getId());\nuser.setFirstName(group.getId());\nuser.setEmailVerified(true);\nuser.setEmail(group.getId() + \"@nanopay.net\");\nuser.setPassword(group.getId() + \"Ab1\");\nprint(user.getFirstName());\ntry { userDAO.put(user); } catch (Throwable t) { t.printStackTrace(); }\n}","output":"0\nccMerchant\nccAdmin\ntester\nadmin\nccShopper\n","notes":""})
p({"class":"foam.nanos.script.Script","id":"sftp","description":"sftp","lastRun":"2017-12-04T21:23:18.148Z","server":true,"scheduled":false,"code":"var sftp = x.get(\"alternaSftp\");\n\nsftp.sendCICOFile();","output":"","notes":""})
p({"class":"foam.nanos.script.Script","id":"showRandomDepositAmounts","description":"Show random bank account deposit amounts.","code":"dao = x.get(\"localAccountDAO\");\na = dao.select().getArray();\n\nfor ( int i = 0 ; i < a.size() ; i++ ) {\n  account = a.get(i);\n  if ( account instanceof net.nanopay.bank.BankAccount ) {\n    amount = account.getRandomDepositAmount();\n    amountFormatted = amount >= 10 ? amount.toString() : \"0\" + amount.toString();\n    print(account.getName() + \" [id = \" + account.getId() + \"]\" + \": $0.\" + amountFormatted);\n  }\n}\n"})
p({"class":"foam.nanos.script.Script","id":"createMissingUserAccounts","description":"Create Balance for Users who don't already have one.","lastRun":"2017-12-12T20:21:12.903Z","server":true,"scheduled":false,"code":"userDAO = x.get(\"userDAO\");\nbalanceDAO = x.get(\"localBalanceDAO\");\n\nusers = userDAO.select().getArray();\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nuser = users.get(i);\naccount = balanceDAO.find(user.getId());\n\nif ( account == null ) {\naccount = new net.nanopay.account.Balance();\naccount.setId(user.getId());\naccount.setOwner(user.getId());\nprint(\"creating \" + user.getId());\nbalanceDAO.put(account);\n}\n}\n\nprint(\"done\");","output":"creating 1345\ncreating 1346\ncreating 1347\ncreating 1348\ncreating 1349\ncreating 1350\ncreating 1354\ncreating 1356\ncreating 1006\ncreating 1007\ncreating 1008\ncreating 1009\ndone\n","notes":""})
p({"class":"foam.nanos.script.Script","id":"createTestTransactions","description":"Creates test transactions to and from users","lastRun":"2017-12-21T22:02:52.502Z","server":true,"scheduled":false,"code":"balanceDAO = x.get(\"localBalanceDAO\");\ntransactionDAO = x.get(\"localTransactionDAO\");\nuserDAO = x.get(\"userDAO\");\n\nusers = userDAO.select().getArray();\n\naccounts = balanceDAO.select().getArray();\n\nfor ( int i = 0 ; i < accounts.size() ; i++ ) {\naccount = accounts.get(i);\naccount.setBalance(1000000);\nprint(\"Balance set to 1000000 for account with id: \" + account.getId());\n}\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nuser = users.get(i);\naccount = balanceDAO.find(user.getId());\nif ( account == null ) {\naccount = new net.nanopay.account.Balance();\naccount.setId(user.getId());\naccount.setOwner(user.getId());\naccount.setBalance(1000000);\nprint(\"creating account for user with ID: \" + user.getId());\nbalanceDAO.put(account);\n}\n}\n\nfor ( int i = 0; i < 500 ; i++ ) {\nfi = (int) (Math.random()*users.size());\nti = (int) (Math.random()*users.size());\namount = (int) ((Math.random() + 0.1) * 10000);\nif ( users.get(ti).id != users.get(fi).id ) {\ntransaction = new net.nanopay.tx.model.Transaction();\ntransaction.setPayeeId(users.get(ti).id);\ntransaction.setPayerId(users.get(fi).id);\ntransaction.setAmount(amount);\nprint(\"sending \" + amount + \" to user with ID: \" + users.get(ti).id);\ntransactionDAO.put(transaction);\n}\n}\n\nprint(\"Done\"); ","output":"","notes":""})
p({"class":"foam.nanos.script.Script","id":"benchmarkTransactions","lastRun":"2018-01-22T13:43:55.407Z","lastDuration":135,"scheduled":false,"code":"x.get(\"transactionDAO\").removeAll();\nx.get(\"transactionLimitDAO\").removeAll();\nbalanceDAO = x.get(\"localBalanceDAO\");\ntransactionDAO = x.get(\"localTransactionDAO\");\nuserDAO = x.get(\"userDAO\");\n\nusers = userDAO.select().getArray();\n\naccounts = balanceDAO.select().getArray();\n\nfor ( int i = 0 ; i < accounts.size() ; i++ ) {\naccount = accounts.get(i);\naccount.setBalance(1000000);\n//print(\"Balance set to 1000000 for account with id: \" + account.getId());\n}\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nuser = users.get(i);\naccount = balanceDAO.find(user.getId());\nif ( account == null ) {\naccount = new net.nanopay.account.Balance();\naccount.setId(user.getId());\naccount.setOwner(user.getId());\n}\naccount.setBalance(1000000);\n//print(\"creating account for user with ID: \" + user.getId());\nbalanceDAO.put(account);\n}\n\npm = new foam.nanos.pm.PM(Object.class, \"Create 10k txns\");\nfor ( int i = 0; i < 1000 ; i++ ) {\nfi = (int) (Math.random()*users.size());\nti = (int) (Math.random()*users.size());\namount = (int) ((Math.random() + 0.1) * 10000);\namount = 1;\nif ( users.get(ti).id != users.get(fi).id ) {\ntransaction = new net.nanopay.tx.model.Transaction();\ntransaction.setPayeeId(users.get(ti).id);\ntransaction.setPayerId(users.get(fi).id);\ntransaction.setAmount(amount);\n// print(\"sending \" + amount + \" to user with ID: \" + users.get(ti).id);\n// transactionDAO.put(transaction);\n}\n}\n\npm.log(x);\nprint(\"Done\"); \n\n","output":"Done\n"})
p({"class":"foam.nanos.script.Script","id":"benchmarkRSASignatureGeneration","description":"Concurrent RSA Signature Generation Benchmark","code":"import foam.nanos.bench.*;\nimport net.nanopay.bench.*;\n\nx = x.put(\"pmLogger\", null);\nb = new SignatureGenerationBenchmark(\"RSA\", \"SHA256\");\nbuilder = new BenchmarkRunner.Builder(x).setThreadCount(2).setInvocationCount(10000).setBenchmark(b);\nrunner = builder.build();\nrunner.execute(x);"})
p({"class":"foam.nanos.script.Script","id":"benchmarkRSASignatureVerification","description":"Concurrent RSA Signature Verification Benchmark","code":"import foam.nanos.bench.*;\nimport net.nanopay.bench.*;\n\nx = x.put(\"pmLogger\", null);\nb = new SignatureVerificationBenchmark(\"RSA\", \"SHA256\");\nbuilder = new BenchmarkRunner.Builder(x).setThreadCount(2).setInvocationCount(10000).setBenchmark(b);\nrunner = builder.build();\nrunner.execute(x);"})
p({"class":"foam.nanos.script.Script","id":"benchmarkECSignatureGeneration","description":"Concurrent EC Signature Generation Benchmark","code":"import foam.nanos.bench.*;\nimport net.nanopay.bench.*;\n\nx = x.put(\"pmLogger\", null);\nb = new SignatureGenerationBenchmark(\"EC\", \"SHA256\");\nbuilder = new BenchmarkRunner.Builder(x).setThreadCount(2).setInvocationCount(10000).setBenchmark(b);\nrunner = builder.build();\nrunner.execute(x);"})
p({"class":"foam.nanos.script.Script","id":"benchmarkECSignatureVerification","description":"Concurrent EC Signature Verification Benchmark","code":"import foam.nanos.bench.*;\nimport net.nanopay.bench.*;\n\nx = x.put(\"pmLogger\", null);\nb = new SignatureVerificationBenchmark(\"EC\", \"SHA256\");\nbuilder = new BenchmarkRunner.Builder(x).setThreadCount(2).setInvocationCount(10000).setBenchmark(b);\nrunner = builder.build();\nrunner.execute(x);"})
p({"class":"foam.nanos.script.Script","id":"HashingJDAO","description":"Tests the HashingJDAO","code":"balanceDAO = x.get(\"localBalanceDAO\");\ntransactionDAO = x.get(\"hashingTxnDAO\");\nuserDAO = x.get(\"userDAO\");\n\nusers = userDAO.select().getArray();\n\naccounts = balanceDAO.select().getArray();\n\nfor ( int i = 0 ; i < accounts.size() ; i++ ) {\naccount = accounts.get(i);\naccount.setBalance(1000000);\nprint(\"Balance set to 1000000 for account with id: \" + account.getId());\n}\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nuser = users.get(i);\naccount = balanceDAO.find(user.getId());\nif ( account == null ) {\naccount = new net.nanopay.account.Balance();\naccount.setId(user.getId());\naccount.setOwner(user.getId());\naccount.setBalance(1000000);\nprint(\"creating account for user with ID: \" + user.getId());\nbalanceDAO.put(account);\n}\n}\n\nfor ( int i = 0; i < 500 ; i++ ) {\nfi = (int) (Math.random()*users.size());\nti = (int) (Math.random()*users.size());\namount = (int) ((Math.random() + 0.1) * 10000);\nif ( users.get(ti).id != users.get(fi).id ) {\ntransaction = new net.nanopay.tx.model.Transaction();\ntransaction.setPayeeId(users.get(ti).id);\ntransaction.setPayerId(users.get(fi).id);\ntransaction.setAmount(amount);\nprint(\"sending \" + amount + \" to user with ID: \" + users.get(ti).id);\ntransactionDAO.put(transaction);\n}\n}\n\nprint(\"Done\"); "})
p({"class":"foam.nanos.script.Script","id":"RollingHashingJDAO","description":"Tests the RollingHashingJDAO","code":"balanceDAO = x.get(\"localBalanceDAO\");\ntransactionDAO = x.get(\"rollingHashingTxnDAO\");\nuserDAO = x.get(\"userDAO\");\n\nusers = userDAO.select().getArray();\n\naccounts = balanceDAO.select().getArray();\n\nfor ( int i = 0 ; i < accounts.size() ; i++ ) {\naccount = accounts.get(i);\naccount.setBalance(1000000);\nprint(\"Balance set to 1000000 for account with id: \" + account.getId());\n}\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nuser = users.get(i);\naccount = balanceDAO.find(user.getId());\nif ( account == null ) {\naccount = new net.nanopay.account.Balance();\naccount.setId(user.getId());\naccount.setOwner(user.getId());\naccount.setBalance(1000000);\nprint(\"creating account for user with ID: \" + user.getId());\nbalanceDAO.put(account);\n}\n}\n\nfor ( int i = 0; i < 500 ; i++ ) {\nfi = (int) (Math.random()*users.size());\nti = (int) (Math.random()*users.size());\namount = (int) ((Math.random() + 0.1) * 10000);\nif ( users.get(ti).id != users.get(fi).id ) {\ntransaction = new net.nanopay.tx.model.Transaction();\ntransaction.setPayeeId(users.get(ti).id);\ntransaction.setPayerId(users.get(fi).id);\ntransaction.setAmount(amount);\nprint(\"sending \" + amount + \" to user with ID: \" + users.get(ti).id);\ntransactionDAO.put(transaction);\n}\n}\n\nprint(\"Done\"); "})
p({"class":"foam.nanos.script.Script","id":"TransactionHashingAndSigning","description":"Demonstrates the rolling hashing functionality as well as signature generation and verification","code":"import foam.nanos.bench.Benchmark;\nimport java.math.BigInteger;\nimport java.security.*;\nimport java.security.spec.*;\nimport org.bouncycastle.util.encoders.Hex;\n\n// generate keypair\nsrand = SecureRandom.getInstance(\"SHA1PRNG\");\nkeygen = KeyPairGenerator.getInstance(\"RSA\");\nspec = new RSAKeyGenParameterSpec(2048, new BigInteger(\"10001\", 16));\nkeygen.initialize(spec, srand);\nkeypair = keygen.generateKeyPair();\n\nt1 = new net.nanopay.tx.model.Transaction();\nt1.setPayerId(1000);\nt1.setPayeeId(9999);\nt1.setAmount(100);\nt1.setDate(new java.util.Date(1517587648897L));\n\n// hash transaction\nh1 = t1.hash();\nprint(\"transaction hash 1: \" + Hex.toHexString(h1));\n\nt2 = new net.nanopay.tx.model.Transaction();\nt2.setPayerId(9999);\nt2.setPayeeId(1000);\nt2.setAmount(2000);\nt2.setDate(new java.util.Date(1517587648900L));\n\n// hash transaction on it's own, and with old transaction\nh2 = t2.hash();\nh3 = t2.hash(h1);\nprint(\"transaction hash 2: \" + Hex.toHexString(h2));\nprint(\"rolled hash of transaction 1 & 2: \" + Hex.toHexString(h3));\n\ns1 = t1.sign(keypair.getPrivate());\nprint(\"transaction 1 signature: \" + Hex.toHexString(s1));\nprint(\"verify transaction 1 signature: \" + t1.verify(s1, keypair.getPublic()));"})
p({"class":"foam.nanos.script.Script","id":"UserHashingAndSigning","description":"Demonstrates the rolling hashing functionality as well as signature generation and verification","code":"import foam.nanos.bench.Benchmark;\nimport java.math.BigInteger;\nimport java.security.*;\nimport java.security.spec.*;\nimport org.bouncycastle.util.encoders.Hex;\n\n// generate keypair\nsrand = SecureRandom.getInstance(\"SHA1PRNG\");\nkeygen = KeyPairGenerator.getInstance(\"RSA\");\nspec = new RSAKeyGenParameterSpec(2048, new BigInteger(\"10001\", 16));\nkeygen.initialize(spec, srand);\nkeypair = keygen.generateKeyPair();\n\nu1 = new foam.nanos.auth.User();\nu1.setId(1000);\nu1.setFirstName(\"Test\");\nu1.setLastName(\"User 1\");\nu1.setEmail(\"test1@nanopay.net\");\nu1.setType(\"Business\");\nu1.setBirthday(new java.util.Date(1265068800L));\n\n// hash user\nh1 = u1.hash();\nprint(\"user hash 1: \" + Hex.toHexString(h1));\n\nu2 = new foam.nanos.auth.User();\nu2.setId(1000);\nu2.setFirstName(\"Test\");\nu2.setLastName(\"User 2\");\nu2.setEmail(\"test2@nanopay.net\");\nu2.setType(\"Business\");\nu2.setBirthday(new java.util.Date(1265068900L));\n\n// hash transaction on it's own, and with old transaction\nh2 = u2.hash();\nh3 = u2.hash(h1);\nprint(\"transaction hash 2: \" + Hex.toHexString(h2));\nprint(\"rolled hash of transaction 1 & 2: \" + Hex.toHexString(h3));\n\ns1 = u1.sign(keypair.getPrivate());\nprint(\"user 1 signature: \" + Hex.toHexString(s1));\nprint(\"verify user 1 signature: \" + u1.verify(s1, keypair.getPublic()));"})
p({"class":"foam.nanos.script.Script","id":"SigningJDAO","description":"Test the SigningJDAO","code":"balanceDAO = x.get(\"localBalanceDAO\");\ntransactionDAO = x.get(\"signingTxnDAO\");\nuserDAO = x.get(\"userDAO\");\n\nusers = userDAO.select().getArray();\n\nbalances = balanceDAO.select().getArray();\n\nfor ( int i = 0 ; i < balances.size() ; i++ ) {\nbalance = balances.get(i);\nbalance.setBalance(1000000);\nprint(\"Balance set to 1000000 for balance with id: \" + balance.getId());\n}\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nuser = users.get(i);\nbalance = balanceDAO.find(user.getId());\nif ( balance == null ) {\nbalance = new net.nanopay.model.Balance();\nbalance.setId(user.getId());\nbalance.setOwner(user.getId());\nbalance.setBalance(1000000);\nprint(\"creating balance for user with ID: \" + user.getId());\nbalanceDAO.put(balance);\n}\n}\n\nfor ( int i = 0; i < 500 ; i++ ) {\nfi = (int) (Math.random()*users.size());\nti = (int) (Math.random()*users.size());\namount = (int) ((Math.random() + 0.1) * 10000);\nif ( users.get(ti).id != users.get(fi).id ) {\ntransaction = new net.nanopay.tx.model.Transaction();\ntransaction.setPayeeId(users.get(ti).id);\ntransaction.setPayerId(users.get(fi).id);\ntransaction.setAmount(amount);\nprint(\"sending \" + amount + \" to user with ID: \" + users.get(ti).id);\ntransactionDAO.put(transaction);\n}\n}\n\nprint(\"Done\"); "})
p({"class":"foam.nanos.script.Script","id":"emailVerified","description":"Verifies user emails","lastRun":"2018-04-21T16:10:27.397Z","lastDuration":154,"code":"userDAO = x.get(\"localUserDAO\");\n\nusers = userDAO.select().getArray();\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\n  user = users.get(i);\n  user.setEmailVerified(true);\n  userDAO.put(user);\n}\n\nprint(\"done.\");","output":"done\n"})
p({"class":"foam.nanos.script.Script","id":"fixUserServiceProviders","enabled":true,"description":"Fixes the users service providers based on their group","lastDuration":0,"server":true,"status":1,"code":"userDAO = x.get(\"localUserDAO\");\nusers = userDAO.select().getArray();\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\n  user = users.get(i);\n  if ( \"ccShopper\".equals(user.getGroup()) || \"ccMerchant\".equals(user.getGroup()) || \"ccAdmin\".equals(user.getGroup()) ) {\n    user.setSpid(\"connected-city\");\n  } else {\n    user.setSpid(\"nanopay\");\n  }\n  userDAO.put(user);\n}\n\nprint(\"done\");","output":"","notes":""})
p({"class":"foam.nanos.script.Script","id":"onboardUsers","enabled":false,"description":"Updates all users so that it appears they have gone through onboarding process","lastDuration":0,"server":true,"status":1,"code":"userDAO = x.get(\"localUserDAO\");\n\nusers = userDAO.select().getArray();\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nuser = users.get(i);\nuser.setStatus(net.nanopay.admin.model.AccountStatus.ACTIVE);\nuser.setCompliance(net.nanopay.admin.model.ComplianceStatus.PASSED);\nuser.setOnboarded(true);\nuser.setCreatedPwd(true);\nuserDAO.put(user);\n}\n\nprint(\"done\");","output":"","notes":"To be run once on Production"})
p({"class":"foam.nanos.script.Script","id":"statusUpdate","description":"Updates the account status and compliance status to active and passed","code":"userDAO = x.get(\"localUserDAO\");\n\nusers = userDAO.select().getArray();\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nuser = users.get(i);\nuser.setStatus(net.nanopay.admin.model.AccountStatus.ACTIVE);\nuser.setCompliance(net.nanopay.admin.model.ComplianceStatus.PASSED);\nuser.setOnboarded(true);\nuserDAO.put(user);\n}\n\nprint(\"done\");"})
p({"class":"foam.nanos.script.Script","id":"Test Email","lastRun":"2018-05-09T18:01:51.784Z","lastDuration":33,"scheduled":false,"code":"import foam.util.Emails.EmailsUtility;\n\n\nuser = x.get(\"user\");\n\nmessage = new foam.nanos.notification.email.EmailMessage();\nmessage.setTo(new String[] { user.getEmail() });\nmap = new java.util.HashMap();\n\nmap.put(\"content\", user.getFirstName());\ntest(EmailsUtility.sendEmailFromTemplate(user, message, \"testEmail\", map), \"email template test\");\nprint(\"DONE\");"})
p({"class":"foam.nanos.script.Script","id":"encryptUsers","description":"Puts all existing users into the encrypted user dao","lastDuration":0,"server":true,"status":1,"code":"userDAO = x.get(\"localUserDAO\");\nencryptedUserDAO = x.get(\"encryptedUserDAO\");\n\nusers = userDAO.select().getArray();\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nencryptedUserDAO.put(users.get(i));\n}\n\nprint(\"done\");","output":"","notes":""})
p({"class":"foam.nanos.script.Script","id":"encryptBankAccounts","description":"Puts all existing bank accounts into the encrypted bank account dao","lastDuration":0,"server":true,"status":1,"code":"bankAccountDAO= x.get(\"localAccountDAO\");\nencryptedBankAccountDAO = x.get(\"encryptedBankAccountDAO\");\n\nbanks = accountDAO.select().getArray();\n\nfor ( int i = 0 ; i < banks.size() ; i++ ) {\nencryptedBankAccountDAO.put(banks.get(i));\n}\n\nprint(\"done\");","output":"","notes":""})
//p({"class":"foam.nanos.script.Script","id":"encryptBankAccounts","description":"Puts all existing bank accounts into the encrypted bank account dao","lastDuration":0,"server":true,"status":1,"code":"bankAccountDAO= x.get(\"localBankAccountDAO\");\nencryptedBankAccountDAO = x.get(\"encryptedBankAccountDAO\");\n\nbanks = bankAccountDAO.select().getArray();\n\nfor ( int i = 0 ; i < banks.size() ; i++ ) {\nencryptedBankAccountDAO.put(banks.get(i));\n}\n\nprint(\"done\");","output":"","notes":""})
p({"class":"foam.nanos.script.Script","id":"fixPasswordExpiry","enabled":false,"description":"Updates all users so that password expiry is null","lastDuration":0,"server":true,"status":1,"code":"userDAO = x.get(\"localUserDAO\");\n\nusers = userDAO.select().getArray();\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nuser = users.get(i);\nuser.setPasswordExpiry(null);\nuserDAO.put(user);\n}\n\nprint(\"done\");","output":""})
p({"class":"foam.nanos.script.Script","id":"Migrate BusinessAddress address2 -> suite","description":"Migrate current user businessAddress address2 data to suite.","code":"userDAO = x.get(\"localUserDAO\");\n\nusers = userDAO.select().getArray();\n\nfor ( int i = 0 ; i < users.size() ; i++ ) {\nuser = users.get(i);\nuser = user.fclone();\naddress = user.getBusinessAddress();\nif ( address != null ) {\naddress2 = address.getAddress2();\naddress.setSuite(address2);\naddress.setAddress2(\"\");\nuser.setBusinessAddress(address);\nuserDAO.put(user);\n}\n}\n\nprint(\"Migration complete.\");\n"})
p({"class":"foam.nanos.script.Script","id":"TestReporter","description":"Generate a report on the number of tests and post it to a Slack channel.","code":"reporter = new net.nanopay.test.TestsReporter();\nreporter.generateNewReport(x);"})
p({"class":"foam.nanos.script.Script","id":"Set destinationCurrency on existing invoices","code":"invoiceDAO = x.get(\"invoiceDAO\");\n\ninvoices = invoiceDAO.select().getArray();\n\nfor ( int i = 0; i < invoices.size(); i++ ) {\ninvoice = invoices.get(i);\nif (invoice.getDestinationCurrency() == null){\ninvoice.setDestinationCurrency(\"CAD\");\ninvoiceDAO.put(invoice);\n}\n}\n\nprint(\"Done.\");"})
p({"class":"foam.nanos.script.Script","id":"Transactions Script: Create","enabled":false,"code":"userDAO             = x.get(\"userDAO\");\naccountDAO          = x.get(\"accountDAO\");\ninstitutionDAO      = x.get(\"institutionDAO\");\ntransactionDAO      = x.get(\"localTransactionDAO\");\nbalanceDAO          = x.get(\"balanceDAO\");\nliquidityDAO        = x.get(\"liquiditySettingsDAO\");\nRandom ran          = new Random();\n\n//Create a Admin User\nuser = new foam.nanos.auth.User();\nuser.setId(Long.valueOf(9999));\nuser.setGroup(\"admin\");\nuser.setOrganization(\"Admin\");\nuser.setEmailVerified(true);\nuser.setFirstName(\"AD\");\nuser.setLastName(\"MIN\");\nuser.setEmail(\"ad@min.com\");\nuserDAO.put(user);\nadmin = (foam.nanos.auth.User) userDAO.find(9999);\nuserDigitalAccount  = net.nanopay.account.DigitalAccount.findDefault(x,admin,\"CAD\");\nls = new net.nanopay.liquidity.LiquiditySettings();\nls.setEnableCashIn(false);\nls.setEnableCashOut(false);\nls.setId(userDigitalAccount.getId());\nliquidityDAO.put(ls);\n\n//Create a bank account to User 9999\naccount = new  net.nanopay.bank.BankAccount();\naccount.setAccountNumber(\"\"+(ran.nextInt(1000000)+10000));\naccount.setInstitution(Long.valueOf(ran.nextInt(99)+1));\naccount.setOwner(admin.getId());\naccount.setName(\"\"+ran.nextInt(1000));\naccount.setStatus(net.nanopay.bank.BankAccountStatus.VERIFIED);\naccount.setDenomination(\"CAD\");\naccount.setId(1351);\naccountDAO.put(account);\nprint(\"Account made\");\n\n//Cashin to User 1000\nfor( int i = 0 ; i< 100 ; i++ ) {\ntransaction = new net.nanopay.tx.model.Transaction();\ntransaction.setDestinationAccount(userDigitalAccount.getId());\ntransaction.setSourceAccount(1351);\ntransaction.setAmount(1000000);\\ntransaction.setStatus(net.nanopay.tx.model.TransactionStatus.COMPLETED);\ntransactionDAO.put(transaction);\n}\nprint(\"CashIn made\");\n\n//Create 1000 users and transfer some DC  \nfor ( int i = 3000 ; i < 4000 ; i++ ) {\nuser = new foam.nanos.auth.User();\nuser.setId(Long.valueOf(i));\nuser.setGroup(\"business\");\nuser.setOrganization(\"Balony\");\nuser.setEmailVerified(true);\nuser.setFirstName(\"account\");\nuser.setLastName(\"\"+i);\nuser.setEmail(\"test\"+i+\"@t.com\");\nuserDAO.put(user);\ndA = net.nanopay.account.DigitalAccount.findDefault(x,user,\"CAD\");\nls = new net.nanopay.liquidity.LiquiditySettings();\nls.setEnableCashIn(false);\nls.setEnableCashOut(false);\nls.setId(dA.getId());\nliquidityDAO.put(ls);\ntransaction = new net.nanopay.tx.model.Transaction();\ntransaction.setDestinationAccount(dA.getId());\ntransaction.setSourceAccount(userDigitalAccount.getId());\ntransaction.setAmount(100000);\ntransaction.setStatus(net.nanopay.tx.model.TransactionStatus.COMPLETED);\ntransactionDAO.put(transaction);\n}\nprint(\"DONE\");"})
p({"class":"foam.nanos.script.Script","id":"Transactions Script: Transfer","enabled":false,"code":"userDAO        = x.get(\"userDAO\");\naccountDAO     = x.get(\"accountDAO\");\ninstitutionDAO = x.get(\"institutionDAO\");\ntransactionDAO = x.get(\"localTransactionDAO\");\nbalanceDAO     = x.get(\"balanceDAO\");\nRandom ran = new Random();\n\n// Creates x transactions between created accounts\nfor ( int i = 0 ; i<1000 ; i++ )\n{\nuser1 = (foam.nanos.auth.User) userDAO.find(Long.valueOf(ran.nextInt(1000)+3000));\nuser2 = (foam.nanos.auth.User) userDAO.find(Long.valueOf(ran.nextInt(1000)+3000));\nif ( user1.getId() == user2.getId()){\ni--;\ncontinue;\n}\naccount1 = net.nanopay.account.DigitalAccount.findDefault(x,user1,\"CAD\");\naccount2 = net.nanopay.account.DigitalAccount.findDefault(x,user2,\"CAD\");\n\ntransaction = new net.nanopay.tx.model.Transaction();\ntransaction.setDestinationAccount(account1.getId());\ntransaction.setSourceAccount(account2.getId());\ntransaction.setAmount(100);\ntransaction.setStatus(net.nanopay.tx.model.TransactionStatus.COMPLETED);\ntransactionDAO.put(transaction);\n\nif ( ((foam.mlang.sink.Sum) balanceDAO.select(foam.mlang.MLang.SUM(net.nanopay.account.Balance.BALANCE))).getValue() != 100000000) \n{print(\"\" + transaction.getId());\nthrow new Error(\"SUM out of sync\");} \n}\nprint(\"DONE\")"})
p({"class":"foam.nanos.script.Script","id":"Transactions Script: CleanUp","enabled":false,"code":"userDAO             = x.get(\"userDAO\");\naccountDAO          = x.get(\"accountDAO\");\ninstitutionDAO      = x.get(\"institutionDAO\");\ntransactionDAO      = x.get(\"localTransactionDAO\");\nbalanceDAO          = x.get(\"balanceDAO\");\nRandom ran          = new Random();\nadmin               = (foam.nanos.auth.User) userDAO.find(9999);\nuserDigitalAccount  = net.nanopay.account.DigitalAccount.findDefault(x,admin,\"CAD\");\n\nfor (int i = 3000 ; i < 4000 ; i++) {\nuser        = (foam.nanos.auth.User) userDAO.find(Long.valueOf(i));\naccount     = net.nanopay.account.DigitalAccount.findDefault(x,user,\"CAD\");\ntransaction = new net.nanopay.tx.model.Transaction();\ntransaction.setDestinationAccount(userDigitalAccount.getId());\ntransaction.setSourceAccount(account.getId());\ntransaction.setAmount(account.findBalance(x));;\ntransaction.setStatus(net.nanopay.tx.model.TransactionStatus.COMPLETED);\ntransactionDAO.put(transaction);\n}\nprint(\"DONE\")"})p({"class":"foam.nanos.script.Script","id":"Transactions Script: 1M Transfer","enabled":false,"code":"userDAO        = x.get(\"userDAO\");\naccountDAO     = x.get(\"accountDAO\");\ninstitutionDAO = x.get(\"institutionDAO\");\ntransactionDAO = x.get(\"localTransactionDAO\");\nbalanceDAO     = x.get(\"balanceDAO\");\nRandom ran = new Random();\n\nlong[][] accountArray = new long[1000000][2];\n\nfor ( int i = 0 ; i<1000000 ; i++ )\n{\n  user1 = (foam.nanos.auth.User) userDAO.find(Long.valueOf(ran.nextInt(1000)+3000));\n  user2 = (foam.nanos.auth.User) userDAO.find(Long.valueOf(ran.nextInt(1000)+3000));\n\n  accountArray[i][0]= net.nanopay.account.DigitalAccount.findDefault(x,user1,\"CAD\").getId();\n  accountArray[i][1]= net.nanopay.account.DigitalAccount.findDefault(x,user2,\"CAD\").getId();\n\n}\nlong time = System.currentTimeMillis();\n\n// Creates x transactions between created accounts\nfor ( int i = 0 ; i<1000 ; i++ )\n{\n  transaction = new net.nanopay.tx.model.Transaction();\n  transaction.setDestinationAccount(accountArray[i][0]);\n  transaction.setSourceAccount(accountArray[i][1]);\n  transaction.setAmount(100);\n  transaction.setStatus(net.nanopay.tx.model.TransactionStatus.COMPLETED);\n  transactionDAO.put(transaction);\n}\nprint(System.currentTimeMillis() - time);\nprint(\"DONE\")"})
p({"class":"foam.nanos.script.Script","id":"Transactions Script: 1M Transfer","enabled":false,"code":"userDAO        = x.get(\"userDAO\");\naccountDAO     = x.get(\"accountDAO\");\ninstitutionDAO = x.get(\"institutionDAO\");\ntransactionDAO = x.get(\"localTransactionDAO\");\nbalanceDAO     = x.get(\"balanceDAO\");\nRandom ran = new Random();\n\nlong[][] accountArray = new long[1000000][2];\n\nfor ( int i = 0 ; i<1000000 ; i++ )\n{\n  user1 = (foam.nanos.auth.User) userDAO.find(Long.valueOf(ran.nextInt(1000)+3000));\n  user2 = (foam.nanos.auth.User) userDAO.find(Long.valueOf(ran.nextInt(1000)+3000));\n\n  accountArray[i][0]= net.nanopay.account.DigitalAccount.findDefault(x,user1,\"CAD\").getId();\n  accountArray[i][1]= net.nanopay.account.DigitalAccount.findDefault(x,user2,\"CAD\").getId();\n\n}\nlong time = System.currentTimeMillis();\n\n// Creates x transactions between created accounts\nfor ( int i = 0 ; i<1000 ; i++ )\n{\n  transaction = new net.nanopay.tx.model.Transaction();\n  transaction.setDestinationAccount(accountArray[i][0]);\n  transaction.setSourceAccount(accountArray[i][1]);\n  transaction.setAmount(100);\n  transaction.setStatus(net.nanopay.tx.model.TransactionStatus.COMPLETED);\n  transactionDAO.put(transaction);\n}\nprint(System.currentTimeMillis() - time);\nprint(\"DONE\")"})
p({"class":"foam.nanos.script.Script","id":"pkcs11keystore","code":"import java.security.*;\nimport java.security.spec.*;\nimport javax.crypto.KeyGenerator;\n\nmanager = x.get(\"keyStoreManager\");\nprint(manager);\n\nkeyStore = manager.getKeyStore();\nprint(keyStore);\n\nkeygen = KeyGenerator.getInstance(\"AES\", manager.getProvider());\nkeygen.init(256, foam.util.SecurityUtil.GetSecureRandom());\nkey = keygen.generateKey();\n\nprint(key);\n"})
p({"class":"foam.nanos.script.Script","id":"MigrateBusinessTypes","description":"The ids of the business types are changing, so we need to migrate the existing users' business types.","code":"import foam.dao.ArraySink;\u000aimport foam.nanos.auth.User;\u000a\u000alocalUserDAO = x.get(\"localUserDAO\");\u000a\u000aList users = (localUserDAO.select(new ArraySink())).getArray();\u000a\u000afor ( User user : users ) {\u000a  id = user.getBusinessTypeId();\u000a  newId =\u000a    id == 0 ? 1\u000a  : id == 1 ? 2\u000a  : id == 5 ? 4\u000a            : 3;\u000a  user = (User) user.fclone();\u000a  user.setBusinessTypeId(newId);\u000a  user = localUserDAO.put(user);\u000a  if ( user.getBusinessTypeId() == newId ) {\u000a    print(\"Successfully changed business id for user with id = \" + Long.toString(user.getId()) + \" from \" + Long.toString(id) + \" to \" + Long.toString(newId));\u000a  } else {\u000a    print(\"Failed to change business id for user with id = \" + Long.toString(user.getId()));\u000a  }\u000a}"})
r({"class":"foam.nanos.script.Script","id":"MigrateBusinessTypes"})
p({"class":"foam.nanos.script.Script","id":"Migrate signing officers","description":"Migrate signing officers from a single property to a many-to-many relationship.","code":"// IMPORTANT:\u000a//   Look for WARNING in the script output when you run it. If you don't see it,\u000a//   then everything should be fine.\u000a\u000aimport foam.dao.ArraySink;\u000aimport foam.mlang.MLang;\u000aimport foam.nanos.auth.User;\u000aimport foam.nanos.auth.UserUserJunction;\u000aimport foam.mlang.predicate.Predicate;\u000aimport net.nanopay.model.Business;\u000aimport net.nanopay.model.BusinessUserJunction;\u000aimport java.util.List;\u000a\u000alocalUserDAO = x.get(\"localUserDAO\");\u000alocalBusinessDAO = x.get(\"localBusinessDAO\");\u000asigningOfficerJunctionDAO = x.get(\"signingOfficerJunctionDAO\");\u000aagentJunctionDAO = x.get(\"agentJunctionDAO\");\u000a\u000a// Look up all of the signing officers.\u000aofficers = (localUserDAO\u000a  .where(foam.mlang.MLang.EQ(User.SIGNING_OFFICER, true))\u000a  .select(new ArraySink())).getArray();\u000a\u000afor ( User officer : officers ) {\u000a  print(\"Processing user '\" + officer.getLegalName() + \"':\");\u000a\u000a  // Find out what businesses they are in.\u000a  junctions = (agentJunctionDAO\u000a    .where(foam.mlang.MLang.EQ(UserUserJunction.SOURCE_ID, officer.getId()))\u000a    .select(new ArraySink())).getArray();\u000a\u000a  Long[] businessIds = new Long[junctions.size()];\u000a\u000a  for ( int i = 0; i < junctions.size(); i++ ) {\u000a    UserUserJunction junction = junctions.get(i);\u000a    businessIds[i] = junction.getTargetId();\u000a  }\u000a\u000a  businesses = (localBusinessDAO\u000a    .where(MLang.IN(User.ID, businessIds))\u000a    .select(new ArraySink())).getArray();\u000a\u000a  if ( businesses.size() > 1 ) {\u000a    print(\"  - WARNING: This user was in multiple businesses and was marked as a signing officer. We must contact that customer to make sure they are in fact a signing officer in all of those companies.\");\u000a  }\u000a\u000a  for ( User business : businesses ) {\u000a    // Check if the junction already exists.\u000a    existingJunction = signingOfficerJunctionDAO.find(\u000a      MLang.AND(new Predicate[] {\u000a        MLang.EQ(BusinessUserJunction.SOURCE_ID, business.getId()),\u000a        MLang.EQ(BusinessUserJunction.TARGET_ID, officer.getId())\u000a      })\u000a    );\u000a\u000a    if ( existingJunction != null ) {\u000a      print(\"  - Already has a junction for this business, skipping to next business.\");\u000a      continue;\u000a    }\u000a\u000a    // Create the junction.\u000a    print(\"  - Creating new junction for Business '\" + business.label() + \"'.\");\u000a    junc = new BusinessUserJunction.Builder(x)\u000a      .setSourceId(business.getId())\u000a      .setTargetId(officer.getId())\u000a      .build();\u000a    signingOfficerJunctionDAO.put(junc);\u000a  }\u000a\u000a  print(\"\");\u000a}"})
p({"class":"foam.nanos.script.Script","id":"SanitizeServicePermissions","code":"nSpecDAO = x.nSpecDAO;\ngroupDAO = x.groupDAO;\n\nbasicUser = groupDAO.find('basicUser').then(function(basicUser) {\nprint(\"all: \"+basicUser.permissions.length);\nbasicUser.permissions = basicUser.permissions.filter(function(p) { return ! p.id.startsWith('service.'); });\nprint(\"filtered: \"+basicUser.permissions.length);\nnSpecDAO.select(function(s) {\nif ( s.id.startsWith('ascendant') ) return;\nif ( s.id.startsWith('flinks') ) return;\nif ( s.id.startsWith('email') ) return;\nif ( s.id.startsWith('alterna') ) return;\nif ( s.id.startsWith('plaid') ) return;\nif ( s.id.startsWith('local') ) return;\nif ( s.id == 'smtpEmailService' ) return;\nif ( s.id == 'pop3' ) return;\nif ( s.id == 'EFTReturnFileCredentials' ) return;\n\nprint(s.id);\n\n/*basicUser.permissions.push(foam.nanos.auth.Permission.create({id: 'service.' + s.id}));*/\nbasicUser.permissions.push(foam.nanos.auth.Permission.create({id: 'service.read.' + s.id}));\nbasicUser.permissions.push(foam.nanos.auth.Permission.create({id: 'service.execute.' + s.id}));\n}).then(function() {\nprint('done');\nprint(\"services: \"+basicUser.permissions.length);\ngroupDAO.put(basicUser);\n});\n});","output":""})
p({"class":"foam.nanos.script.Script","id":"Migrate Beneficial Owners","description":"Migrate Beneficial Owners to use relationship instead of array property","code":"import foam.dao.DAO;\u000aimport foam.dao.ArraySink;\u000aimport foam.nanos.auth.User;\u000aimport net.nanopay.model.Business;\u000aimport net.nanopay.model.BeneficialOwner;\u000a\u000aDAO businessDAO = x.get(\"businessDAO\");\u000a\u000abusinesses = (businessDAO.select(new ArraySink())).getArray();\u000a\u000afor ( Business business : businesses ) {\u000a  for ( User u : business.getPrincipalOwners() ) {\u000a    BeneficialOwner b = new BeneficialOwner();\u000a    b.setFirstName(u.getFirstName());\u000a    b.setLastName(u.getLastName());\u000a    b.setAddress(u.getAddress());\u000a    b.setBirthday(u.getBirthday());\u000a    b.setJobTitle(u.getJobTitle());\u000a\u000a    try {\u000a      business.getBeneficialOwners(x).put(b);\u000a      print(\"✓: Successfully converted beneficial owner \" + u.label() + \".\");\u000a    } catch (Throwable t) {\u000a      print(\"❌: Failed to convert \" + u.label() + \" to a beneficial owner.\");\u000a      print(t.getMessage());\u000a    }\u000a  }\u000a}\u000a\u000a"})
p({"class":"foam.nanos.script.Script","id":"port nanoconnect user to ablii","description":"Creates businesses for nanoconnect users and copies the existing user to the new business. Creates a new user and associates it to the business created. Provides the admin permission to the nanoconnect user created. Invoice, transactions & bank account are associated to the new business created based on the UID transferred from the nano connect user.","code":"import net.nanopay.model.Business;\nimport foam.nanos.auth.Group;\nimport foam.nanos.auth.Permission;\nimport foam.nanos.auth.UserUserJunction;\nimport foam.core.X;\n\nuserDAO = x.get(\"userDAO\");\nbareUserDAO = x.get(\"bareUserDAO\");\ngroupDAO = x.get(\"groupDAO\");\nbusinessDAO = x.get(\"businessDAO\");\nagentJunctionDAO = x.get(\"agentJunctionDAO\");\n\npublic Permission[] generatePermissions(X x, Group templateGroup, String safeBusinessName) {\npermissionDAO  = x.get(\"permissionDAO\");\nPermission[] templatePermissions = templateGroup.getPermissions();\nPermission[] newPermissions = new Permission[templatePermissions.length];\nfor ( int i = 0; i < templatePermissions.length; i++ ) {\nPermission templatePermission = templatePermissions[i];\nPermission newPermission = new Permission(templatePermission.getId().replaceAll(\".id.\", \".\" + safeBusinessName + \".\"), templatePermission.getDescription());\nnewPermissions[i] = newPermission;\n\n// Put as the system since permissionDAO is authenticated.\npermissionDAO.put(newPermission);\n}\nreturn newPermissions;\n}\n\n// Replace this email array with a list of emails of user to be ported to ablii.\nString [] emails = { \"pop12345@gmail.com\" };\n\nfor (int i = 0; i < emails.length; i++) {\nuser = userDAO.find(foam.mlang.MLang.EQ(foam.nanos.auth.User.EMAIL, emails[i]));\nbusiness = businessDAO.find(foam.mlang.MLang.EQ(Business.EMAIL, emails[i]));\nif (business != null) continue;\nbusiness = new net.nanopay.model.Business.Builder(x).build();\nbusiness.copyFrom(user);\nbusiness.setLoginEnabled(false);\nbusiness.setType(\"Business\");\nbusinessName = foam.util.SafetyUtil.isEmpty(business.getBusinessName()) ? business.getOrganization() : business.getBusinessName();\nbusiness.setBusinessName(businessName);\nbareUserDAO.remove(user);\nnewUser = new foam.nanos.auth.User.Builder(x).build();\nnewUser.copyFrom(user);\nnewUser.setId(0);\nnewUser.setGroup(\"sme\");\nnewUser = bareUserDAO.put(newUser);\nbusiness = bareUserDAO.put(business);\n\nString safeBusinessName = business.getBusinessPermissionId();\n\n// When creating a business, 3 groups are also created that are associated\n// with the business.\nGroup adminTemplateGroup = (Group) groupDAO.find(\"smeBusinessAdmin\");\nGroup approverTemplateGroup = (Group) groupDAO.find(\"smeBusinessApprover\");\nGroup employeeTemplateGroup = (Group) groupDAO.find(\"smeBusinessEmployee\");\n\nGroup employeeGroup = new Group();\nemployeeGroup.copyFrom(employeeTemplateGroup);\nemployeeGroup.setId(safeBusinessName + \".employee\");\nemployeeGroup.setPermissions(generatePermissions(x, employeeTemplateGroup, safeBusinessName));\nemployeeGroup.setBusiness(business.getId());\nemployeeGroup.setParent(\"sme\");\ngroupDAO.put(employeeGroup);\n\nGroup approverGroup = new Group();\napproverGroup.copyFrom(approverTemplateGroup);\napproverGroup.setId(safeBusinessName + \".approver\");\napproverGroup.setPermissions(generatePermissions(x, approverTemplateGroup, safeBusinessName));\napproverGroup.setBusiness(business.getId());\napproverGroup.setParent(safeBusinessName + \".employee\");\ngroupDAO.put(approverGroup);\n\nGroup adminGroup = new Group();\nadminGroup.copyFrom(adminTemplateGroup);\nadminGroup.setId(safeBusinessName + \".admin\");\nadminGroup.setPermissions(generatePermissions(x, adminTemplateGroup, safeBusinessName));\nadminGroup.setBusiness(business.getId());\nadminGroup.setParent(safeBusinessName + \".approver\");\ngroupDAO.put(adminGroup);\n\n// Put the business itself in the admin group for the business.\nbusiness = business.fclone();\nbusiness.setGroup(safeBusinessName + \".admin\");\nbusiness.setEmailVerified(true);\nbusiness = bareUserDAO.put(business);\n\n// Create a relationship between the user and the business. Set the group on\n// the junction object to the admin group for that business.\nUserUserJunction junction = new UserUserJunction();\njunction.setGroup(adminGroup.getId());\njunction.setSourceId(newUser.getId());\njunction.setTargetId(business.getId());\nagentJunctionDAO.put(junction);\n}"})
p({"class":"foam.nanos.script.Script","id":"Anonymize Journals","description":"Anonymize user name,email,phone numbers, address and account numbers","code":"import net.nanopay.bank.BankAccount;\nimport foam.nanos.app.AppConfig;\nimport foam.nanos.app.Mode;\nimport foam.nanos.auth.Address;\nimport foam.nanos.auth.Phone;\n\nrunScript = false;\naccountNumber = 1234567;\nuserNameLength =7;\nuserEmailLength = 12;\nPhone phone = new Phone();\nMap emails = new HashMap();\nimportObject(emails);\n\naccountDAO = x.get(\"accountDAO\");\nuserDAO = x.get(\"userDAO\");\naccounts = accountDAO.select().getArray();\nusers = userDAO.select().getArray();\n\n\nString getRandomNumber(int length) {\n  String chars = \"1234567890\";\n  StringBuilder number = new StringBuilder();\n  Random rnd = new Random();\n  while (number.length() < length) {\n    int index = (int) (rnd.nextFloat() * chars.length());\n    number.append(chars.charAt(index));\n  }\n  return number.toString();\n}\n\nString getRandomString(int length) {\n  String chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  StringBuilder name = new StringBuilder();\n  Random rnd = new Random();\n  while (name.length() < length) {\n    int index = (int) (rnd.nextFloat() * chars.length());\n    name.append(chars.charAt(index));\n  }\n  return name.toString();\n}\n\n//create address that is added to every user/business\nAddress address = new Address();\naddress.setCountryId(\"CA\");\naddress.setRegionId(\"ON\");\naddress.setPostalCode(\"M4B1A2\");\naddress.setSuite(\"1\");\naddress.setLongitude(1.0);\naddress.setLatitude(1.0);\n\n\n// Check if in production enviroment\nif ( ((AppConfig) x.get(\"appConfig\")).getMode() == Mode.PRODUCTION ) {\n  print(\"Can not run this script in a production enviroment\");\n  return;\n}\n\nif ( runScript) {\n  for (account : accounts) {\n    account = account.fclone();\n    if ( account instanceof BankAccount) {\n      account.setAccountNumber(accountNumber + \"\");\n      accountNumber++;\n    }\n    accountDAO.put(account);\n  }\n\n\n  for (user : users) {\n    user = user.fclone();\n    user.setFirstName(getRandomString(userNameLength));\n    user.setMiddleName(getRandomString(userNameLength));\n    user.setLastName(getRandomString(userNameLength));\n    user.setDesiredPassword(\"password\");\n\n    address.setCity(\"city\" + getRandomNumber(4));\n    address.setStreetName(\"street\" + getRandomNumber(4));\n    address.setStreetNumber(\"123\" + getRandomNumber(4));\n    address.setAddress1(getRandomString(10));\n    address.setAddress2(getRandomString(10));\n    user.setAddress(address);\n    user.setBusinessAddress(address);\n\n    phone.setNumber(getRandomNumber(9));\n    user.setPhone(phone);\n    user.setMobile(phone);\n    user.setBusinessPhone(phone);\n    user.setPhoneNumber(getRandomNumber(9));\n\n    if ( user.getGroup().equals(\"admin\" )) {\n\n    } else {\n      if (emails.containsKey(user.getEmail())){\n        user.setEmail(emails.get(user.getEmail()));\n      } else {\n        temp = getRandomString(userEmailLength) + \"@nanopay.net\";\n        emails.put(user.getEmail(), temp);\n        user.setEmail(temp);\n      }\n    }\n    if ( user.getId() != 1 && user.getId() !=1346) {\n      try {\n        userDAO.put(user);\n      } catch(Exception ex){\n      }\n    }\n  }\n\n  print(\"Done\");\n} else  {\n  print(\"Set runScript to true in this script code to run.\");\n  print(\"Backup your current journals before running this script.\");\n  print(\"WARNING this will make changes to your current journals.\");\n}","notes":"DO NOT RUN ON PRODUCTION. THIS SCRIPT WILL MODIFY CURRENT JOURNALS."})
p({"class":"foam.nanos.script.Script","id":"Add userManagement menu to business admin group","description":"Migration script to add a permission to existing business groups","lastRun":"2019-03-14T16:05:51.973Z","lastDuration":32,"code":"import foam.dao.DAO;\u000aimport foam.dao.ArraySink;\u000aimport foam.nanos.auth.User;\u000aimport foam.nanos.auth.Group;\u000aimport foam.nanos.auth.Permission;\u000aimport net.nanopay.model.Business;\u000aimport javax.security.auth.AuthPermission;\u000a\u000aDAO businessDAO = (DAO) x.get(\"businessDAO\");\u000aDAO groupDAO = (DAO) x.get(\"groupDAO\");\u000a\u000abusinesses = businessDAO.select(new ArraySink()).getArray();\u000aint i;\u000a\u000afor ( Business business : businesses ) {\u000a  Group group = business.findGroup(x);\u000a\u000a  if ( group.implies(x, new AuthPermission(\"menu.read.sme.*\")) ) {\u000a    print(\"Group \" + group.getId() + \" already has a permission that implies the one we're adding. Skipping.\");\u000a    continue;\u000a  }\u000a\u000a  Permission[] permissions = group.getPermissions();\u000a  Permission[] newPermissions = new Permission[permissions.length + 1];\u000a\u000a  for ( i = 0; i < permissions.length; i++ ) {\u000a    newPermissions[i] = permissions[i];\u000a  }\u000a\u000a  newPermissions[i] = new Permission.Builder(x).setId(\"menu.read.sme.*\").build();\u000a  group.setPermissions(newPermissions);\u000a  groupDAO.put(group);\u000a  print(\"Successfully added permission '\" + newPermissions[i].getId() + \"' to group \" + group.getId());\u000a}\u000a","output":"Group nanopay8006.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup examplecompany28010.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup quintewestpubliclibrary8013.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup haiprecisionwaterjets8015.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup companywithusdbankaccount8018.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup testingissue54228023.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup hoserscarwash8025.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup papajohnspizza8028.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup passwordtestingcompany8032.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup synctestcompany8034.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup passporttestcompany8038.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup snowinc8040.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup adsfds8042.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup corneriainc8044.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup bombardier8046.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup testcompanyemailverified8048.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup accountingcompanyinc8050.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup reporttestcompany8055.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup asdfas8057.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup modusristorante8059.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup abccompany8062.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup warnerbros8064.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup haiprecisionwaterjetsinc8067.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup millersmills8069.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup banktestcompany8071.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup dateofbirthtestcompany8073.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup company58578075.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup asdfcompany8077.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup fdsas8079.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup signingofficercompany8081.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup busprofilecompany8083.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup arizonacompany8086.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup beverlyschool8092.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup linktestcompany8094.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup signuptestone8096.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup homehardware8098.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup fieldcompany8103.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup datefieldtestcompany8105.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup bellevillebulls8107.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup woolersoccerinc8109.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup smitherslandscaping8111.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup georgeswashingmachines8113.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup dragonsden8115.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup vladssomethings8117.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup finaldestinationdeliverycompany8119.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup royscompany8121.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup kirbyskico8123.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup asdfsadfsa8125.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup fasdfdsafsadf8127.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup luigisplumbing8129.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup foxdalefarms8131.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup lyleslanyards8133.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup cleancodepublishing8135.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup dunno8137.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup linkupdatecompany8139.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup rubyyacht8143.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup scallopshotel8145.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup adfsafsd8147.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup overlaptestcompany8150.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup gothamshipping8155.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup fsdfsad8157.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup sdfdfs8159.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup sadfsafd8161.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup businessprofilebackendvalidationcompany8163.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup testinglockincompany8165.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup balzacs8167.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup channelorange8169.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup janbarelectric8171.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup sd8180.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup sdfsdaf8182.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup artofhappiness8184.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup bostonteacompany8186.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup tisane8189.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup scotties8191.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup fdsf8194.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup asdfsa8196.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup safsfs8199.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup adsfdsa8203.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup fsadf8206.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup fsafdsdf8209.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup lkjadslfkj8212.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup lasdf8218.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup laksjdf8220.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup fasfasdf8223.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup laksdjf8226.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup lskdfjlk8229.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup alsdkjf8232.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup sadfsad8235.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup asldkfj8238.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup lakjdfsl8240.admin already has a permission that implies the one we're adding. Skipping.\u000aGroup alskdfj8243.admin already has a permission that implies the one we're adding. Skipping.\u000a"})
p({"class":"foam.nanos.script.Script","id":"addPermsToFraudOps","description":"Create various read/write permissions for the \"fraud-ops\" group if they do not exist.","code":"/**\n * TITLE: addPermsToFraudOps\n * DESCRIPTION: Create various read/write permissions for the \"fraud-ops\" group if they do not exist.\n */\nimport foam.nanos.auth.Group;\nimport foam.dao.DAO;\nimport foam.nanos.auth.Permission;\nimport foam.core.X;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// ==================================================================================\n\n/**\n * Declaring \"fraud-ops\" and its requested permissions as variables up here\n * That way the script is REUSABLE if anyone wants to create permissions for any group\n * IMPORTANT: Before running the script, you will need to add a \"permissionRequired: true\" property to\n * your desired model properties in order for this script to work.\n * Make sure to LOWERCASIFY THE WHOLE PERMISSION and write the SPECIFIC MODELS\n * \n * \n * Once the model properties have been edited, just add: \n * 1. groupID\n * 2. permsToAdd\n */\ngroupID = \"fraud-ops\";\nString[] permsToAdd = {\n    \"transaction.rw.status\",\n    \"alternacotransaction.rw.status\",\n    \"alternacitransaction.rw.status\",\n    \"abliitransaction.rw.status\",\n    \"transaction.update.*\",\n    \"bankaccount.rw.status\",\n    \"bankaccount.rw.verificationattempts\",\n    \"usbankaccount.rw.status\",\n    \"usbankaccount.rw.verificationattempts\",\n    \"cabankaccount.rw.status\",\n    \"cabankaccount.rw.verificationattempts\",\n    \"digitalaccount.rw.status\",\n    \"business.update.*\"\n};\n\n// =================================================================================\n\n// grabbing the group's permissions property and permissionDAO\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\npermissionDAO  = x.get(\"permissionDAO\");\n\n// FOR DEBUGGING\nprint(\"START\");\nprint(\"************************\");\nprint(\"GroupID: \" + groupID);\nprint(\"\");\nprint(\"CurrentPermissions: \");\nprint(groupPerms);\nprint(\"\");\nprint(\"PermissionsToAdd: \");\nprint(permsToAdd);\nprint(\"\");\nprint(\"\");\n\n/**\n * we place the following loop at the top in order to act as a fail safe\n * if for some reason only the \"fraud-ops\" group permissions array previously had the requested permissions\n * but the PermissionDAO did not get updated with those same permissions\n * we will then add the requested permissions into the PermissionsDAO only if they are unique\n * this is because later on in the script\n * we end the script if \"fraud-ops\" group permissions array already has all the requested permissions\n * that is why we are updating the permissionsDAO first\n */\nfor ( i = 0; i < permsToAdd.length; i++ ){\n    // here we will also lowercasify the permissions in the array as well while we make this check\n    permsToAdd[i] = permsToAdd[i].toLowerCase();\n\n    currentPermId = permsToAdd[i];\n    if ( permissionDAO.find(currentPermId) == null ) permissionDAO.put(new Permission(currentPermId, \"\"));\n} \n\n/**\n * from here on out we will be dealing solely with the \"fraud-ops\" group permissions' property\n * transforming the primitive array into just a set\n * because as we're deep cloning we can check if there are any duplicates\n * and then just pop them off the set\n */\nSet permsToAddSet = new HashSet();\nfor ( i = 0; i < permsToAdd.length; i++ ) {\n    permsToAddSet.add(permsToAdd[i]);\n}\n\n/**\n * we use an ArrayList instead of a primitive array because\n * we don't know the exact length of the final array if there are duplicates\n */\nList newPermissions = new ArrayList();\n\nfor ( i = 0; i < groupPerms.length; i++ ) {\n    currentPerm = groupPerms[i];\n\n    // 1. deep clone original permissions to new arrayList\n    newPermissions.add(new Permission(currentPerm.id, currentPerm.description));\n\n    // 2. check if permsToAdd is asking for this permission then pop it off because will already have been created\n    if ( permsToAddSet.contains(currentPerm.id) ) permsToAddSet.remove(currentPerm.id);\n}\n\n// if permsToAddSet is empty, that means theres nothing to add\n// we can end the script here\nif ( permsToAddSet.isEmpty() ) {\n    print(\"Ending script here because the \" + groupID + \" group already has all the requested permissions\");\n    print(\"************************\");\n    print(\"END\");\n    return;\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"OriginalPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// here we will iterate through the remaining permsToAdd and place them in the newPermissions arraylist\nfor ( perm : permsToAddSet ) {\n    currentPermission = new Permission(perm, \"\");\n    newPermissions.add(currentPermission);\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"NewPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// making a deep conversion of the newPermissions ArrayList to a primitive array\nPermission[] newPermissionsArray = new Permission[newPermissions.size()];\nfor ( i = 0; i < newPermissionsArray.length; i++ ) {\n    newPermissionsArray[i] = new Permission(newPermissions.get(i).id, newPermissions.get(i).description);\n}\n\n// set newPermissionsArray as new property\ngroup.setPermissions(newPermissionsArray);\n\n// put modified group back into the groupDAO\ngroupDAO.put(group);\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(groupID + \"Group Permissions\");\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\nprint(groupPerms);\nprint(\"=======================\");\nprint(\"\");\nprint(\"************************\");\nprint(\"END\");\n\n"})
p({"class":"foam.nanos.script.Script","id":"addPermsToSme", "description":"Create various read-only permissions for the \"sme\" group if they do not exist.","code":"/**\n* TITLE: addPermsToSme\n* DESCRIPTION: Create various read-only permissions for the \"sme\" group if they do not exist.\n*/\nimport foam.nanos.auth.Group;\nimport foam.dao.DAO;\nimport foam.nanos.auth.Permission;\nimport foam.core.X;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// ==================================================================================\n\n/**\n* Declaring \"sme\" and its requested permissions as variables up here\n* That way the script is REUSABLE if anyone wants to create permissions for any group\n* IMPORTANT: Before running the script, you will need to add a \"permissionRequired: true\" property to\n* your desired model properties in order for this script to work.\n* Make sure to LOWERCASIFY THE WHOLE PERMISSION and write the SPECIFIC MODELS\n* \n* \n* Once the model properties have been edited, just add: \n* 1. groupID\n* 2. permsToAdd\n*/\ngroupID = \"sme\";\nString[] permsToAdd = {\n\"transaction.ro.status\",\n\"alternacotransaction.ro.status\",\n\"alternacitransaction.ro.status\",\n\"abliitransaction.ro.status\",\n\"bankaccount.ro.status\",\n\"bankaccount.ro.verificationattempts\",\n\"cabankaccount.ro.status\",\n\"cabankaccount.ro.verificationattempts\",\n\"usbankaccount.ro.status\",\n\"usbankaccount.ro.verificationattempts\",\n\"digitalaccount.ro.status\"\n};\n\n// =================================================================================\n\n// grabbing the group's permissions property and permissionDAO\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\npermissionDAO  = x.get(\"permissionDAO\");\n\n// FOR DEBUGGING\nprint(\"START\");\nprint(\"************************\");\nprint(\"GroupID: \" + groupID);\nprint(\"\");\nprint(\"CurrentPermissions: \");\nprint(groupPerms);\nprint(\"\");\nprint(\"PermissionsToAdd: \");\nprint(permsToAdd);\nprint(\"\");\nprint(\"\");\n\n/**\n* we place the following loop at the top in order to act as a fail safe\n* if for some reason only the \"sme\" group permissions array previously had the requested permissions\n* but the PermissionDAO did not get updated with those same permissions\n* we will then add the requested permissions into the PermissionsDAO only if they are unique\n* this is because later on in the script\n* we end the script if \"sme\" group permissions array already has all the requested permissions\n* that is why we are updating the permissionsDAO first\n*/\nfor ( i = 0; i < permsToAdd.length; i++ ){\n// here we will also lowercasify the permissions in the array as well while we make this check\npermsToAdd[i] = permsToAdd[i].toLowerCase();\n\ncurrentPermId = permsToAdd[i];\nif ( permissionDAO.find(currentPermId) == null ) permissionDAO.put(new Permission(currentPermId, \"\"));\n} \n\n/**\n* from here on out we will be dealing solely with the \"fraud-ops\" group permissions' property\n* transforming the primitive array into just a set\n* because as we're deep cloning we can check if there are any duplicates\n* and then just pop them off the set\n*/\nSet permsToAddSet = new HashSet();\nfor ( i = 0; i < permsToAdd.length; i++ ) {\npermsToAddSet.add(permsToAdd[i]);\n}\n\n/**\n* we use an ArrayList instead of a primitive array because\n* we don't know the exact length of the final array if there are duplicates\n*/\nList newPermissions = new ArrayList();\n\nfor ( i = 0; i < groupPerms.length; i++ ) {\ncurrentPerm = groupPerms[i];\n\n// 1. deep clone original permissions to new arrayList\nnewPermissions.add(new Permission(currentPerm.id, currentPerm.description));\n\n// 2. check if permsToAdd is asking for this permission then pop it off because will already have been created\nif ( permsToAddSet.contains(currentPerm.id) ) permsToAddSet.remove(currentPerm.id);\n}\n\n// if permsToAddSet is empty, that means theres nothing to add\n// we can end the script here\nif ( permsToAddSet.isEmpty() ) {\nprint(\"Ending script here because the \" + groupID + \" group already has all the requested permissions\");\nprint(\"************************\");\nprint(\"END\");\nreturn;\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"OriginalPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// here we will iterate through the remaining permsToAdd and place them in the newPermissions arraylist\nfor ( perm : permsToAddSet ) {\ncurrentPermission = new Permission(perm, \"\");\nnewPermissions.add(currentPermission);\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"NewPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// making a deep conversion of the newPermissions ArrayList to a primitive array\nPermission[] newPermissionsArray = new Permission[newPermissions.size()];\nfor ( i = 0; i < newPermissionsArray.length; i++ ) {\nnewPermissionsArray[i] = new Permission(newPermissions.get(i).id, newPermissions.get(i).description);\n}\n\n// set newPermissionsArray as new property\ngroup.setPermissions(newPermissionsArray);\n\n// put modified group back into the groupDAO\ngroupDAO.put(group);\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(groupID + \"Group Permissions\");\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\nprint(groupPerms);\nprint(\"=======================\");\nprint(\"\");\nprint(\"************************\");\nprint(\"END\");\n"})
p({"class":"foam.nanos.script.Script","id":"addWhitelistPermsToPaymentOps","description":"Create whitelist update, remove and create permissions for Payment Ops","code":"/**\n* TITLE: addWhitelistPermsToPaymentOps\n* DESCRIPTION: Create whitelist update, remove and create permissions for Payment Ops\n*/\nimport foam.nanos.auth.Group;\nimport foam.dao.DAO;\nimport foam.nanos.auth.Permission;\nimport foam.core.X;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// ==================================================================================\n\n/**\n* Declaring \"payment-ops\" and its requested permissions as variables up here\n* That way the script is REUSABLE if anyone wants to create permissions for any group\n* IMPORTANT: Before running the script, you will need to add a \"permissionRequired: true\" property to\n* your desired model properties in order for this script to work.\n* Make sure to LOWERCASIFY THE WHOLE PERMISSION and write the SPECIFIC MODELS\n* \n* \n* Once the model properties have been edited, just add: \n* 1. groupID\n* 2. permsToAdd\n*/\ngroupID = \"payment-ops\";\nString[] permsToAdd = {\n\"whitelistedEmail.update.*\",\n\"whitelistedEmail.remove.*\",\n\"whitelistedEmail.read.*\",\n\"whitelistedEmail.create\"\n};\n\n//=================================================================================\n\n// grabbing the group's permissions property and permissionDAO\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\npermissionDAO  = x.get(\"permissionDAO\");\n\n// FOR DEBUGGING\nprint(\"START\");\nprint(\"************************\");\nprint(\"GroupID: \" + groupID);\nprint(\"\");\nprint(\"CurrentPermissions: \");\nprint(groupPerms);\nprint(\"\");\nprint(\"PermissionsToAdd: \");\nprint(permsToAdd);\nprint(\"\");\nprint(\"\");\n\n/**\n* we place the following loop at the top in order to act as a fail safe\n* if for some reason only the \"payment-ops\" group permissions array previously had the requested permissions\n* but the PermissionDAO did not get updated with those same permissions\n* we will then add the requested permissions into the PermissionsDAO only if they are unique\n* this is because later on in the script\n* we end the script if \"payment-ops\" group permissions array already has all the requested permissions\n* that is why we are updating the permissionsDAO first\n*/\nfor ( i = 0; i < permsToAdd.length; i++ ){\n/**\n*  ! NOTE: currently commenting out the lowercasifying until \n*  ! lowercase permission standardizations are made\n*  essentially the AuthenticatedDAO does not automatically lowercase permissions when\n*  sending them off to auth.check\n*/\n// here we will also lowercasify the permissions in the array as well while we make this check\n// permsToAdd[i] = permsToAdd[i].toLowerCase();\n\ncurrentPermId = permsToAdd[i];\nif ( permissionDAO.find(currentPermId) == null ) permissionDAO.put(new Permission(currentPermId, \"\"));\n} \n\n/**\n* from here on out we will be dealing solely with the \"payment-ops\" group permissions' property\n* transforming the primitive array into just a set\n* because as we're deep cloning we can check if there are any duplicates\n* and then just pop them off the set\n*/\nSet permsToAddSet = new HashSet();\nfor ( i = 0; i < permsToAdd.length; i++ ) {\npermsToAddSet.add(permsToAdd[i]);\n}\n\n/**\n* we use an ArrayList instead of a primitive array because\n* we don't know the exact length of the final array if there are duplicates\n*/\nList newPermissions = new ArrayList();\n\nfor ( i = 0; i < groupPerms.length; i++ ) {\ncurrentPerm = groupPerms[i];\n\n// 1. deep clone original permissions to new arrayList\nnewPermissions.add(new Permission(currentPerm.id, currentPerm.description));\n\n// 2. check if permsToAdd is asking for this permission then pop it off because will already have been created\nif ( permsToAddSet.contains(currentPerm.id) ) permsToAddSet.remove(currentPerm.id);\n}\n\n// if permsToAddSet is empty, that means theres nothing to add\n// we can end the script here\nif ( permsToAddSet.isEmpty() ) {\nprint(\"Ending script here because the \" + groupID + \" group already has all the requested permissions\");\nprint(\"************************\");\nprint(\"END\");\nreturn;\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"OriginalPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// here we will iterate through the remaining permsToAdd and place them in the newPermissions arraylist\nfor ( perm : permsToAddSet ) {\ncurrentPermission = new Permission(perm, \"\");\nnewPermissions.add(currentPermission);\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"NewPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// making a deep conversion of the newPermissions ArrayList to a primitive array\nPermission[] newPermissionsArray = new Permission[newPermissions.size()];\nfor ( i = 0; i < newPermissionsArray.length; i++ ) {\nnewPermissionsArray[i] = new Permission(newPermissions.get(i).id, newPermissions.get(i).description);\n}\n\n// set newPermissionsArray as new property\ngroup.setPermissions(newPermissionsArray);\n\n// put modified group back into the groupDAO\ngroupDAO.put(group);\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(groupID + \"Group Permissions\");\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\nprint(groupPerms);\nprint(\"=======================\");\nprint(\"\");\nprint(\"************************\");\nprint(\"END\");\n"})
p({"class":"foam.nanos.script.Script","id":"addServicePermsToPaymentOps","description":"Create various service permissions for Payment Ops as a cause of the removal of service.*","code":"/**\n* TITLE: addServicePermsToPaymentOps\n* DESCRIPTION: Create various service permissions for Payment Ops as a cause of the removal of service.*\n*/\nimport foam.nanos.auth.Group;\nimport foam.dao.DAO;\nimport foam.nanos.auth.Permission;\nimport foam.core.X;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// ==================================================================================\n\n/**\n* Declaring \"payment-ops\" and its requested permissions as variables up here\n* That way the script is REUSABLE if anyone wants to create permissions for any group\n* \n* Once the model properties have been edited, just add: \n* 1. groupID\n* 2. permsToAdd\n*/\ngroupID = \"payment-ops\";\nString[] permsToAdd = {\n// TO GET THE OPERATIONS MENU\n\"service.menuDAO\",\n// FROM JUST SELECTING THE OPERATIONS MENU ITEMS\n\"service.accountDAO\",\n\"service.nSpecDAO\",\n\"service.digitalAccount\",\n\"service.notificationDAO\",\n\"service.currencyDAO\",\n\"service.balanceDAO\",\n\"service.groupDAO\",\n\"service.transactionDAO\",\n\"service.invoiceDAO\",\n\"service.flinksAccountsDetailResponseDAO\",\n\"service.loginAttemptDAO\",\n\"service.ipHistoryDAO\",\n\"service.reportDAO\",\n\"service.ticketDAO\",\n\"service.ascendantFXUserDAO\",\n\"service.ascendantUserPayeeJunctionDAO\",\n\"service.whitelistedEmailDAO\",\n\"service.doNotSolicitDAO\",\n\"service.emailMessageDAO\",\n\"service.serviceProviderDAO\",\n// FROM OPERATIONS -> USER -> CREATE\n\"service.businessSectorDAO\",\n\"service.languageDAO\",\n\"service.partnerJunctionDAO\",\n\"service.paymentCardDAO\",\n// FROM OPERATIONS -> ACCOUNT -> CREATE\n\"service.publicKeyDAO\",\n// FROM OPERATIONS -> INVOICE -> CREATE\n\"service.recurringInvoiceDAO\",\n// FROM OPERATIONS → INVOICE → CREATE → SAVE\n\"service.fileDAO\",\n// FROM OPERATIONS → TICKETS → NEW TICKET → SUBMIT AS *\n\"service.ticketMessageDAO\",\n// FROM OPERATIONS → REPORTS → RUN *\n\"service.scriptDAO\",\n// FROM OPERATIONS -> ALTERNA-EFT -> Download csv -> login\n\"service.run.alterna\",\n// FROM OPERATIONS -> SERVICE PROVIDERS -> CREATE\n\"service.lineItemFeeDAO\",\n\"service.lineItemTaxDAO\",\n\"service.lineItemTypeDAO\",\n\"service.transactionFeeDAO\",\n// FROM OPERATIONS → * → EXPORT\n\"service.exportDriverRegistryDAO\",\n// FROM PERSONAL SETTINGS\n\"service.twofactor\",\n// FROM PRODUCTION LOG REQUESTS FOR PAYMENT-OPS\n\"service.supportEmailDAO\"\n,\n\"service.liquiditySettingsDAO\"\n,\n\"service.securefactLEVDAO\"\n,\n\"service.securefactSIDniDAO\"\n,\n\"service.institutionDAO\"\n,\n\"service.branchDAO\"\n};\n\n// =================================================================================\n\n// grabbing the group's permissions property and permissionDAO\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\npermissionDAO  = x.get(\"permissionDAO\");\n\n// FOR DEBUGGING\nprint(\"START\");\nprint(\"************************\");\nprint(\"GroupID: \" + groupID);\nprint(\"\");\nprint(\"CurrentPermissions: \");\nprint(groupPerms);\nprint(\"\");\nprint(\"PermissionsToAdd: \");\nprint(permsToAdd);\nprint(\"\");\nprint(\"\");\n\n/**\n* we place the following loop at the top in order to act as a fail safe\n* if for some reason only the \"payment-ops\" group permissions array previously had the requested permissions\n* but the PermissionDAO did not get updated with those same permissions\n* we will then add the requested permissions into the PermissionsDAO only if they are unique\n* this is because later on in the script\n* we end the script if \"payment-ops\" group permissions array already has all the requested permissions\n* that is why we are updating the permissionsDAO first\n*/\nfor ( i = 0; i < permsToAdd.length; i++ ){\n/**\n*  ! NOTE: currently commenting out the lowercasifying until \n*  ! lowercase permission standardizations are made\n*  ! currently service permissions are all camel-cased\n*/\n// here we will also lowercasify the permissions in the array as well while we make this check\n// permsToAdd[i] = permsToAdd[i].toLowerCase();\n\ncurrentPermId = permsToAdd[i];\nif ( permissionDAO.find(currentPermId) == null ) permissionDAO.put(new Permission(currentPermId, \"\"));\n} \n\n/**\n* from here on out we will be dealing solely with the \"payment-ops\" group permissions' property\n* transforming the primitive array into just a set\n* because as we're deep cloning we can check if there are any duplicates\n* and then just pop them off the set\n*/\nSet permsToAddSet = new HashSet();\nfor ( i = 0; i < permsToAdd.length; i++ ) {\npermsToAddSet.add(permsToAdd[i]);\n}\n\n/**\n* we use an ArrayList instead of a primitive array because\n* we don't know the exact length of the final array if there are duplicates\n*/\nList newPermissions = new ArrayList();\n\nfor ( i = 0; i < groupPerms.length; i++ ) {\ncurrentPerm = groupPerms[i];\n\n// 1. deep clone original permissions to new arrayList\nnewPermissions.add(new Permission(currentPerm.id, currentPerm.description));\n\n// 2. check if permsToAdd is asking for this permission then pop it off because will already have been created\nif ( permsToAddSet.contains(currentPerm.id) ) permsToAddSet.remove(currentPerm.id);\n}\n\n// if permsToAddSet is empty, that means theres nothing to add\n// we can end the script here\nif ( permsToAddSet.isEmpty() ) {\nprint(\"Ending script here because the \" + groupID + \" group already has all the requested permissions\");\nprint(\"************************\");\nprint(\"END\");\nreturn;\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"OriginalPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// here we will iterate through the remaining permsToAdd and place them in the newPermissions arraylist\nfor ( perm : permsToAddSet ) {\ncurrentPermission = new Permission(perm, \"\");\nnewPermissions.add(currentPermission);\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"NewPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// making a deep conversion of the newPermissions ArrayList to a primitive array\nPermission[] newPermissionsArray = new Permission[newPermissions.size()];\nfor ( i = 0; i < newPermissionsArray.length; i++ ) {\nnewPermissionsArray[i] = new Permission(newPermissions.get(i).id, newPermissions.get(i).description);\n}\n\n// set newPermissionsArray as new property\ngroup.setPermissions(newPermissionsArray);\n\n// put modified group back into the groupDAO\ngroupDAO.put(group);\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(groupID + \"Group Permissions\");\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\nprint(groupPerms);\nprint(\"=======================\");\nprint(\"\");\nprint(\"************************\");\nprint(\"END\");\n"})
p({"class":"foam.nanos.script.Script","id":"addServicePermsToSme","description":"Create various service permissions for Sme as a cause of the removal of service.*","code":"/**\n* TITLE: addServicePermsToSme\n* DESCRIPTION: Create various service permissions for Sme as a cause of the removal of service.*\n*/\nimport foam.nanos.auth.Group;\nimport foam.dao.DAO;\nimport foam.nanos.auth.Permission;\nimport foam.core.X;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// ==================================================================================\n\n/**\n* Declaring \"Sme\" and its requested permissions as variables up here\n* That way the script is REUSABLE if anyone wants to create permissions for any group\n* \n* \n* Once the model properties have been edited, just add: \n* 1. groupID\n* 2. permsToAdd\n*/\ngroupID = \"sme\";\nString[] permsToAdd = {\n// (REPLICATE by creating a new bank account for a user)\n\"service.padCaptureDAO\",\n// (attempt to verify a newly created CA bank account)\n\"service.bankAccountVerification\",\n// (click on business settings)\n\"service.bankIntegrationsDAO\",\n// (hit view details on a payable)\n\"service.invoiceHistoryDAO\",\n// (go to bank accounts tab)\n\"service.branchDAO\",\n// (go to signing officer tab on business profile)\n\"service.identificationTypeDAO\",\n\"service.quickbooksService\",\n\"service.run.xeroWebAgent\",\n\"service.run.quickbooksWebAgent\",\n\"service.emailToken\",\n\"service.flinksAuth\",\n\"service.accountingReportDAO\"\n};\n\n// =================================================================================\n\n// grabbing the group's permissions property and permissionDAO\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\npermissionDAO  = x.get(\"permissionDAO\");\n\n// FOR DEBUGGING\nprint(\"START\");\nprint(\"************************\");\nprint(\"GroupID: \" + groupID);\nprint(\"\");\nprint(\"CurrentPermissions: \");\nprint(groupPerms);\nprint(\"\");\nprint(\"PermissionsToAdd: \");\nprint(permsToAdd);\nprint(\"\");\nprint(\"\");\n\n/**\n* we place the following loop at the top in order to act as a fail safe\n* if for some reason only the \"payment-ops\" group permissions array previously had the requested permissions\n* but the PermissionDAO did not get updated with those same permissions\n* we will then add the requested permissions into the PermissionsDAO only if they are unique\n* this is because later on in the script\n* we end the script if \"payment-ops\" group permissions array already has all the requested permissions\n* that is why we are updating the permissionsDAO first\n*/\nfor ( i = 0; i < permsToAdd.length; i++ ){\n/**\n*  ! NOTE: currently commenting out the lowercasifying until \n*  ! lowercase permission standardizations are made\n*  ! currently service permissions are all camel-cased\n*/\n// here we will also lowercasify the permissions in the array as well while we make this check\n// permsToAdd[i] = permsToAdd[i].toLowerCase();\n\ncurrentPermId = permsToAdd[i];\nif ( permissionDAO.find(currentPermId) == null ) permissionDAO.put(new Permission(currentPermId, \"\"));\n} \n\n/**\n* from here on out we will be dealing solely with the \"payment-ops\" group permissions' property\n* transforming the primitive array into just a set\n* because as we're deep cloning we can check if there are any duplicates\n* and then just pop them off the set\n*/\nSet permsToAddSet = new HashSet();\nfor ( i = 0; i < permsToAdd.length; i++ ) {\npermsToAddSet.add(permsToAdd[i]);\n}\n\n/**\n* we use an ArrayList instead of a primitive array because\n* we don't know the exact length of the final array if there are duplicates\n*/\nList newPermissions = new ArrayList();\n\nfor ( i = 0; i < groupPerms.length; i++ ) {\ncurrentPerm = groupPerms[i];\n\n// 1. deep clone original permissions to new arrayList\nnewPermissions.add(new Permission(currentPerm.id, currentPerm.description));\n\n// 2. check if permsToAdd is asking for this permission then pop it off because will already have been created\nif ( permsToAddSet.contains(currentPerm.id) ) permsToAddSet.remove(currentPerm.id);\n}\n\n// if permsToAddSet is empty, that means theres nothing to add\n// we can end the script here\nif ( permsToAddSet.isEmpty() ) {\nprint(\"Ending script here because the \" + groupID + \" group already has all the requested permissions\");\nprint(\"************************\");\nprint(\"END\");\nreturn;\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"OriginalPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// here we will iterate through the remaining permsToAdd and place them in the newPermissions arraylist\nfor ( perm : permsToAddSet ) {\ncurrentPermission = new Permission(perm, \"\");\nnewPermissions.add(currentPermission);\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"NewPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// making a deep conversion of the newPermissions ArrayList to a primitive array\nPermission[] newPermissionsArray = new Permission[newPermissions.size()];\nfor ( i = 0; i < newPermissionsArray.length; i++ ) {\nnewPermissionsArray[i] = new Permission(newPermissions.get(i).id, newPermissions.get(i).description);\n}\n\n// set newPermissionsArray as new property\ngroup.setPermissions(newPermissionsArray);\n\n// put modified group back into the groupDAO\ngroupDAO.put(group);\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(groupID + \"Group Permissions\");\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\nprint(groupPerms);\nprint(\"=======================\");\nprint(\"\");\nprint(\"************************\");\nprint(\"END\");\n"})
p({"class":"foam.nanos.script.Script","id":"addServicePermsToFraudOps","description":"Create various service permissions for Fraud Ops as a cause of the removal of service.*","code":"/**\n* TITLE: addServicePermsToFraudOps\n* DESCRIPTION: Create various service permissions for Fraud Ops as a cause of the removal of service.*\n*/\nimport foam.nanos.auth.Group;\nimport foam.dao.DAO;\nimport foam.nanos.auth.Permission;\nimport foam.core.X;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// ==================================================================================\n\n/**\n* Declaring \"fraud-ops\" and its requested permissions as variables up here\n* That way the script is REUSABLE if anyone wants to create permissions for any group\n* \n* Once the model properties have been edited, just add: \n* 1. groupID\n* 2. permsToAdd\n*/\ngroupID = \"fraud-ops\";\nString[] permsToAdd = {\n// TO GET THE OPERATIONS MENU\n\"service.menuDAO\",\n// FROM JUST SELECTING THE OPERATIONS MENU ITEMS\n\"service.accountDAO\",\n\"service.nSpecDAO\",\n\"service.digitalAccount\",\n\"service.notificationDAO\",\n\"service.currencyDAO\",\n\"service.balanceDAO\",\n\"service.groupDAO\",\n\"service.transactionDAO\",\n\"service.invoiceDAO\",\n\"service.flinksAccountsDetailResponseDAO\",\n\"service.loginAttemptDAO\",\n\"service.ipHistoryDAO\",\n\"service.reportDAO\",\n\"service.ticketDAO\",\n\"service.ascendantFXUserDAO\",\n\"service.ascendantUserPayeeJunctionDAO\",\n\"service.whitelistedEmailDAO\",\n\"service.doNotSolicitDAO\",\n\"service.emailMessageDAO\",\n\"service.serviceProviderDAO\",\n// FROM OPERATIONS -> USER -> CREATE\n\"service.businessSectorDAO\",\n\"service.languageDAO\",\n\"service.partnerJunctionDAO\",\n\"service.paymentCardDAO\",\n// FROM OPERATIONS -> ACCOUNT -> CREATE\n\"service.publicKeyDAO\",\n// FROM OPERATIONS -> INVOICE -> CREATE\n\"service.recurringInvoiceDAO\",\n// FROM OPERATIONS → INVOICE → CREATE → SAVE\n\"service.fileDAO\",\n// FROM OPERATIONS → TICKETS → NEW TICKET → SUBMIT AS *\n\"service.ticketMessageDAO\",\n// FROM OPERATIONS → REPORTS → RUN *\n\"service.scriptDAO\",\n// FROM OPERATIONS -> ALTERNA-EFT -> Download csv -> login\n\"service.run.alterna\",\n// FROM OPERATIONS -> SERVICE PROVIDERS -> CREATE\n\"service.lineItemFeeDAO\",\n\"service.lineItemTaxDAO\",\n\"service.lineItemTypeDAO\",\n\"service.transactionFeeDAO\",\n// FROM OPERATIONS → * → EXPORT\n\"service.exportDriverRegistryDAO\",\n// FROM PERSONAL SETTINGS\n\"service.twofactor\",\n\"service.supportEmailDAO\",\n\"service.liquiditySettingsDAO\",\n\"service.securefactLEVDAO\",\n\"service.securefactSIDniDAO\",\n\"service.branchDAO\",\n\"service.institutionDAO\"\n};\n\n// =================================================================================\n\n// grabbing the group's permissions property and permissionDAO\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\npermissionDAO  = x.get(\"permissionDAO\");\n\n// FOR DEBUGGING\nprint(\"START\");\nprint(\"************************\");\nprint(\"GroupID: \" + groupID);\nprint(\"\");\nprint(\"CurrentPermissions: \");\nprint(groupPerms);\nprint(\"\");\nprint(\"PermissionsToAdd: \");\nprint(permsToAdd);\nprint(\"\");\nprint(\"\");\n\n/**\n* we place the following loop at the top in order to act as a fail safe\n* if for some reason only the \"payment-ops\" group permissions array previously had the requested permissions\n* but the PermissionDAO did not get updated with those same permissions\n* we will then add the requested permissions into the PermissionsDAO only if they are unique\n* this is because later on in the script\n* we end the script if \"payment-ops\" group permissions array already has all the requested permissions\n* that is why we are updating the permissionsDAO first\n*/\nfor ( i = 0; i < permsToAdd.length; i++ ){\n/**\n*  ! NOTE: currently commenting out the lowercasifying until \n*  ! lowercase permission standardizations are made\n*  ! currently service permissions are all camel-cased\n*/\n// here we will also lowercasify the permissions in the array as well while we make this check\n// permsToAdd[i] = permsToAdd[i].toLowerCase();\n\ncurrentPermId = permsToAdd[i];\nif ( permissionDAO.find(currentPermId) == null ) permissionDAO.put(new Permission(currentPermId, \"\"));\n} \n\n/**\n* from here on out we will be dealing solely with the \"payment-ops\" group permissions' property\n* transforming the primitive array into just a set\n* because as we're deep cloning we can check if there are any duplicates\n* and then just pop them off the set\n*/\nSet permsToAddSet = new HashSet();\nfor ( i = 0; i < permsToAdd.length; i++ ) {\npermsToAddSet.add(permsToAdd[i]);\n}\n\n/**\n* we use an ArrayList instead of a primitive array because\n* we don't know the exact length of the final array if there are duplicates\n*/\nList newPermissions = new ArrayList();\n\nfor ( i = 0; i < groupPerms.length; i++ ) {\ncurrentPerm = groupPerms[i];\n\n// 1. deep clone original permissions to new arrayList\nnewPermissions.add(new Permission(currentPerm.id, currentPerm.description));\n\n// 2. check if permsToAdd is asking for this permission then pop it off because will already have been created\nif ( permsToAddSet.contains(currentPerm.id) ) permsToAddSet.remove(currentPerm.id);\n}\n\n// if permsToAddSet is empty, that means theres nothing to add\n// we can end the script here\nif ( permsToAddSet.isEmpty() ) {\nprint(\"Ending script here because the \" + groupID + \" group already has all the requested permissions\");\nprint(\"************************\");\nprint(\"END\");\nreturn;\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"OriginalPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// here we will iterate through the remaining permsToAdd and place them in the newPermissions arraylist\nfor ( perm : permsToAddSet ) {\ncurrentPermission = new Permission(perm, \"\");\nnewPermissions.add(currentPermission);\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"NewPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// making a deep conversion of the newPermissions ArrayList to a primitive array\nPermission[] newPermissionsArray = new Permission[newPermissions.size()];\nfor ( i = 0; i < newPermissionsArray.length; i++ ) {\nnewPermissionsArray[i] = new Permission(newPermissions.get(i).id, newPermissions.get(i).description);\n}\n\n// set newPermissionsArray as new property\ngroup.setPermissions(newPermissionsArray);\n\n// put modified group back into the groupDAO\ngroupDAO.put(group);\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(groupID + \"Group Permissions\");\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\nprint(groupPerms);\nprint(\"=======================\");\nprint(\"\");\nprint(\"************************\");\nprint(\"END\");\n"})
p({"class":"foam.nanos.script.Script","id":"addSugarPermission","description":"Add the sugar permission to various groups because of service.run.dig","code":"/**\n* TITLE: addSugarPermission\n* DESCRIPTION: Add the sugar permission to various groups because of service.run.dig\n*/\nimport foam.nanos.auth.Group;\nimport foam.dao.DAO;\nimport foam.nanos.auth.Permission;\nimport foam.core.X;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// ==================================================================================\n\n/**\n* Declaring \"fraud-ops\" and its requested permissions as variables up here\n* That way the script is REUSABLE if anyone wants to create permissions for any group\n* \n* Once the model properties have been edited, just add: \n* 1. groupIDs\n* 2. permsToAdd\n*/\nString[] groupIDs = {\n    \"sme\",\n    \"gsAdmin\",\n    \"portal-developer\"\n};\nString[] permsToAdd = {\n    \"service.run.sugar\"\n};\n\n// =================================================================================\n\n// grabbing the groupDAO and permissionDAO\ngroupDAO = x.get(\"groupDAO\");\npermissionDAO  = x.get(\"permissionDAO\");\n\n// FOR DEBUGGING\nprint(\"START\");\nprint(\"************************\");\nprint(\"PermissionsToAdd: \");\nprint(permsToAdd);\nprint(\"\");\nprint(\"\");\n\n/**\n* we place the following loop at the top in order to act as a fail safe\n* if for some reason only the \"payment-ops\" group permissions array previously had the requested permissions\n* but the PermissionDAO did not get updated with those same permissions\n* we will then add the requested permissions into the PermissionsDAO only if they are unique\n* this is because later on in the script\n* we end the script if \"payment-ops\" group permissions array already has all the requested permissions\n* that is why we are updating the permissionsDAO first\n*/\nfor ( i = 0; i < permsToAdd.length; i++ ){\n/**\n*  ! NOTE: currently commenting out the lowercasifying until \n*  ! lowercase permission standardizations are made\n*  ! currently service permissions are all camel-cased\n*/\n// here we will also lowercasify the permissions in the array as well while we make this check\n// permsToAdd[i] = permsToAdd[i].toLowerCase();\n\ncurrentPermId = permsToAdd[i];\nif ( permissionDAO.find(currentPermId) == null ) permissionDAO.put(new Permission(currentPermId, \"\"));\n} \n\n/**\n* from here on out we will be dealing solely with the \"payment-ops\" group permissions' property\n* transforming the primitive array into just a set\n* because as we're deep cloning we can check if there are any duplicates\n* and then just pop them off the set\n* Here we will loop through each group and add the \n*/\nfor ( j = 0; j < groupIDs.length; j++ ) {\n    groupID = groupIDs[j];\n\n    print(\"************************\");\n    print(\"Adding to GroupID: \" + groupID);\n    print(\"\");\n\n    Set permsToAddSet = new HashSet();\n    for ( i = 0; i < permsToAdd.length; i++ ) {\n        permsToAddSet.add(permsToAdd[i]);\n    }\n    \n    group = groupDAO.find(groupID);\n    groupPerms = group.permissions;\n\n    print(\"CurrentPermissions: \");\n    print(groupPerms);\n    print(\"\");\n\n    /**\n    * we use an ArrayList instead of a primitive array because\n    * we don't know the exact length of the final array if there are duplicates\n    */\n    List newPermissions = new ArrayList();\n\n    for ( k = 0; k < groupPerms.length; k++ ) {\n        currentPerm = groupPerms[k];\n\n    // 1. deep clone original permissions to new arrayList\n    newPermissions.add(new Permission(currentPerm.id, currentPerm.description));\n\n    // 2. check if permsToAdd is asking for this permission then pop it off because will already have been created\n    if ( permsToAddSet.contains(currentPerm.id) ) permsToAddSet.remove(currentPerm.id);\n    }\n\n    // if permsToAddSet is empty, that means theres nothing to add\n    // we can end the script here\n    if ( permsToAddSet.isEmpty() ) {\n        print(\"Skipping \" + groupID + \" because they already have all the requested permissions\");\n        print(\"************************\");\n        print(\"END\");\n        continue;\n    }\n\n    // FOR DEBUGGING\n    print(\"\");\n    print(\"=======================\");\n    print(\"OriginalPermissions\");\n    print(newPermissions);\n    print(\"=======================\");\n    print(\"\");\n\n    // here we will iterate through the remaining permsToAdd and place them in the newPermissions arraylist\n    for ( perm : permsToAddSet ) {\n    currentPermission = new Permission(perm, \"\");\n    newPermissions.add(currentPermission);\n    }\n\n    // FOR DEBUGGING\n    print(\"\");\n    print(\"=======================\");\n    print(\"NewPermissions\");\n    print(newPermissions);\n    print(\"=======================\");\n    print(\"\");\n\n    // making a deep conversion of the newPermissions ArrayList to a primitive array\n    Permission[] newPermissionsArray = new Permission[newPermissions.size()];\n    for ( i = 0; i < newPermissionsArray.length; i++ ) {\n    newPermissionsArray[i] = new Permission(newPermissions.get(i).id, newPermissions.get(i).description);\n    }\n\n    // set newPermissionsArray as new property\n    group.setPermissions(newPermissionsArray);\n\n    // put modified group back into the groupDAO\n    groupDAO.put(group);\n\n    // FOR DEBUGGING\n    print(\"\");\n    print(\"=======================\");\n    print(groupID + \"Group Permissions\");\n    groupDAO = x.get(\"groupDAO\");\n    group = groupDAO.find(groupID);\n    groupPerms = group.permissions;\n    print(groupPerms);\n    print(\"=======================\");\n    print(\"\");\n}\nprint(\"************************\");\nprint(\"END\");\n","output":""})
p({"class":"foam.nanos.script.Script","id":"main","code":"/* Set AppConfig version from nanopay jar manifest*/\nimport foam.nanos.app.Mode;\nimport foam.nanos.app.AppConfig;\n\nlogger = (foam.nanos.logger.Logger) x.get(\"logger\");\nversion = foam.nanos.app.AppConfig.class.getPackage().getImplementationVersion();\nappConfig = x.get(\"appConfig\");\nif ( ! foam.util.SafetyUtil.isEmpty(version) ) {\n  appConfig.setVersion(version);\n} else if ( foam.util.SafetyUtil.isEmpty(appConfig.getVersion()) ) {\n  appConfig.setVersion(\"1.0.0\");\n}\nmode = System.getProperty(\"appconfig.mode\");\nif ( ! foam.util.SafetyUtil.isEmpty(mode) ) {\n  mode = mode.substring(0,1).toUpperCase() + mode.substring(1).toLowerCase();\n  m = Mode.forLabel(mode);\n  appConfig.setMode(m);\n}\n  \nlogger.log(new Object[] {\"AppConfig\", appConfig});\nprint(appConfig);\n"})
p({"class":"foam.nanos.script.Script","id":"PublicUserInfo update","description":"Migration script to make sure the payer and payee properties are saved on the Invoice model so they can be searched.","lastRun":"2019-04-12T15:17:46.306Z","lastDuration":370,"code":"// Migration script to make sure the payer and payee properties are saved on the Invoice model so they can be searched.\u000a\u000aimport foam.dao.DAO;\u000aimport foam.dao.ArraySink;\u000aimport java.util.List;\u000aimport net.nanopay.invoice.model.Invoice;\u000a\u000ainvoiceDAO = (DAO) x.get(\"invoiceDAO\");\u000a\u000aList invoices = (invoiceDAO.select(new ArraySink())).getArray();\u000a\u000afor ( Invoice invoice : invoices ) {\u000a  try {\u000a    invoiceDAO.put(invoice);\u000a    print(\"Updated: \" + Long.toString(invoice.id));\u000a  } catch (Throwable t) {\u000a    print(\"Couldn't update: \" + Long.toString(invoice.id));\u000a  }\u000a}","output":"Updated: 136\u000aUpdated: 135\u000aUpdated: 134\u000aUpdated: 133\u000aUpdated: 132\u000aUpdated: 131\u000aUpdated: 130\u000aUpdated: 129\u000aUpdated: 128\u000aUpdated: 127\u000aUpdated: 126\u000aUpdated: 125\u000aUpdated: 124\u000aUpdated: 123\u000aUpdated: 122\u000aUpdated: 121\u000aUpdated: 120\u000aUpdated: 119\u000aUpdated: 118\u000aUpdated: 117\u000aUpdated: 116\u000aUpdated: 115\u000aUpdated: 114\u000aUpdated: 113\u000aUpdated: 112\u000aUpdated: 111\u000aUpdated: 110\u000aUpdated: 109\u000aUpdated: 108\u000aUpdated: 107\u000aUpdated: 106\u000aUpdated: 105\u000aUpdated: 104\u000aUpdated: 103\u000aUpdated: 102\u000aUpdated: 101\u000aUpdated: 100\u000aUpdated: 99\u000aUpdated: 98\u000aUpdated: 97\u000aUpdated: 96\u000aUpdated: 95\u000aUpdated: 94\u000aUpdated: 93\u000aUpdated: 92\u000aUpdated: 91\u000aUpdated: 90\u000aUpdated: 89\u000aUpdated: 88\u000aUpdated: 87\u000aUpdated: 86\u000aUpdated: 85\u000aUpdated: 84\u000aUpdated: 83\u000aUpdated: 82\u000aUpdated: 81\u000aUpdated: 80\u000aUpdated: 79\u000aUpdated: 78\u000aUpdated: 77\u000aUpdated: 76\u000aUpdated: 75\u000aUpdated: 74\u000aUpdated: 73\u000aUpdated: 72\u000aUpdated: 71\u000aUpdated: 70\u000aUpdated: 69\u000aUpdated: 68\u000aUpdated: 67\u000aUpdated: 66\u000aUpdated: 65\u000aUpdated: 64\u000aUpdated: 63\u000aUpdated: 62\u000aUpdated: 61\u000aUpdated: 60\u000aUpdated: 59\u000aUpdated: 58\u000aUpdated: 57\u000aUpdated: 56\u000aUpdated: 55\u000aUpdated: 54\u000aUpdated: 53\u000aUpdated: 52\u000aUpdated: 51\u000aUpdated: 50\u000aUpdated: 49\u000aUpdated: 48\u000aUpdated: 47\u000aUpdated: 46\u000aUpdated: 41\u000aUpdated: 40\u000aUpdated: 39\u000aUpdated: 38\u000aUpdated: 37\u000aUpdated: 36\u000aUpdated: 35\u000aUpdated: 34\u000aUpdated: 33\u000aUpdated: 32\u000aUpdated: 31\u000aUpdated: 27\u000aUpdated: 26\u000aUpdated: 25\u000aUpdated: 24\u000aUpdated: 23\u000aUpdated: 22\u000aUpdated: 21\u000aUpdated: 20\u000aUpdated: 19\u000aUpdated: 18\u000aUpdated: 17\u000aUpdated: 16\u000aUpdated: 15\u000aUpdated: 14\u000aUpdated: 13\u000aUpdated: 12\u000aUpdated: 11\u000aUpdated: 10\u000aUpdated: 9\u000aUpdated: 8\u000aUpdated: 7\u000aUpdated: 6\u000aUpdated: 5\u000aUpdated: 4\u000aUpdated: 3\u000aUpdated: 2\u000aUpdated: 1\u000aCouldn't update: 30\u000aCouldn't update: 45\u000a"})
p({"class":"foam.nanos.script.Script","id":"3247d52a-08a1-4793-80a2-2bd095ed714b","description":"Add action permissions to payment-ops group","lastRun":"2019-04-15T19:01:26.031Z","lastDuration":10,"code":"// Add action permissions to payment-ops group\u000a\u000aimport foam.core.X;\u000aimport foam.dao.DAO;\u000aimport foam.nanos.auth.AuthService;\u000aimport foam.nanos.auth.Group;\u000aimport foam.nanos.auth.Permission;\u000aimport java.security.BasicPermission;\u000a\u000agroupDAO = ((DAO) x.get(\"localGroupDAO\")).inX(x);\u000aauth = (AuthService) x.get(\"auth\");\u000a\u000agroup = (Group) groupDAO.find(\"payment-ops\");\u000a\u000aX groupCtx = x.put(\"group\", group);\u000a\u000aString[] permissionsToAdd = {\u000a  \"foam.nanos.auth.User.permission.viewAccounts\",\u000a  \"foam.nanos.auth.User.permission.viewTransactions\",\u000a  \"foam.nanos.auth.User.permission.viewPayables\",\u000a  \"foam.nanos.auth.User.permission.viewReceivables\"\u000a};\u000a\u000afor ( String permissionId : permissionsToAdd ) {\u000a  if ( auth.check(groupCtx, permissionId) ) {\u000a    print(\"Already has \" + permissionId + \".\");\u000a  } else {\u000a    print(\"Need to add \" + permissionId + \".\");\u000a    Permission[] currentPermissions = group.getPermissions();\u000a    Permission[] newPermissions = new Permission[currentPermissions.length + 1];\u000a    for ( int i = 0; i < currentPermissions.length; i++ ) {\u000a      newPermissions[i] = currentPermissions[i];\u000a    }\u000a    newPermissions[currentPermissions.length] = new Permission(permissionId, \"\");\u000a    group.setPermissions(newPermissions);\u000a    print(\"Added \" + permissionId + \".\");\u000a  }\u000a}\u000a\u000agroupDAO.put(group);","output":"Already has foam.nanos.auth.User.permission.viewAccounts.\u000aAlready has foam.nanos.auth.User.permission.viewTransactions.\u000aAlready has foam.nanos.auth.User.permission.viewPayables.\u000aAlready has foam.nanos.auth.User.permission.viewReceivables.\u000a"})
p({"class":"foam.nanos.script.Script","id":"d7bea66a-c769-4933-8445-4589066757c5","description":"Add service permissions to sme group","lastRun":"2019-04-17T21:17:29.747Z","lastDuration":15,"code":"// Add service permissions to sme group\u000a\u000aimport foam.core.X;\u000aimport foam.dao.DAO;\u000aimport foam.nanos.auth.AuthService;\u000aimport foam.nanos.auth.Group;\u000aimport foam.nanos.auth.Permission;\u000aimport java.security.BasicPermission;\u000a\u000agroupDAO = ((DAO) x.get(\"localGroupDAO\")).inX(x);\u000aauth = (AuthService) x.get(\"auth\");\u000a\u000a// Adds permissions to the group.\u000avoid addPermissionsToGroup(String[] permissionsToAdd, String groupId) {\u000a  group = (Group) groupDAO.find(groupId);\u000a  X groupCtx = x.put(\"group\", group);\u000a  for ( String permissionId : permissionsToAdd ) {\u000a    if ( auth.check(groupCtx, permissionId) ) {\u000a      print(\"Group \" + groupId + \" already has \" + permissionId + \".\");\u000a    } else {\u000a      print(\"Need to add \" + permissionId + \" to \" + groupId + \".\");\u000a      Permission[] currentPermissions = group.getPermissions();\u000a      Permission[] newPermissions = new Permission[currentPermissions.length + 1];\u000a      for ( int i = 0; i < currentPermissions.length; i++ ) {\u000a        newPermissions[i] = currentPermissions[i];\u000a      }\u000a      newPermissions[currentPermissions.length] = new Permission(permissionId, \"\");\u000a      group.setPermissions(newPermissions);\u000a      print(\"Added \" + permissionId + \" to \" + groupId + \".\");\u000a    }\u000a  }\u000a  groupDAO.put(group);\u000a}\u000a\u000aString[] groups = {\u000a  \"sme\"\u000a};\u000a\u000aString[] permissionsToAdd = {\u000a  \"service.beneficialOwnerDAO\",\u000a  \"service.signingOfficerJunctionDAO\"\u000a};\u000a\u000afor ( String groupId : groups ) {\u000a  print(groupId + \":\");\u000a  addPermissionsToGroup(permissionsToAdd, groupId);\u000a  print(\"\");\u000a}\u000a","output":"sme:\u000aGroup sme already has service.beneficialOwnerDAO.\u000aGroup sme already has service.signingOfficerJunctionDAO.\u000a\u000a"})
p({"class":"foam.nanos.script.Script","id":"addSupportLogs","server":false,"description":"To give the support logs menu access to payment-ops under the operations menu","code":"/**\n * TITLE: addSupportLogs\n * DESCRIPTION: To give the support logs menu access to payment-ops under the operations menu\n */\n\nprint(\"START 🏁\");\n\nconst promises = [];\n\n// 1. Create the submenu\nconst menuDAO = x['menuDAO'];\n\nconst supportLogMenu = foam.nanos.menu.Menu.create({\n  id: 'supportLogs',\n  parent: \"operation\",\n  handler: foam.nanos.menu.DAOMenu.create({\n      daoKey: 'logMessageDAO',\n      title: \"Server Log\",\n      createEnabled: false\n  }, x),\n  label: 'Support Logs',\n  order: 1000\n});\n\nmenuDAO.put(supportLogMenu);\n\n// 2. Give the Support group permissions to service.logMessageDAO\n// creating the permission to be added\nconst newPaymentOpsPermission = foam.nanos.auth.Permission.create({\n  id: \"service.logMessageDAO\"\n})\n\nconst  newSupportLogsPermission = foam.nanos.auth.Permission.create({\n  id: \"menu.read.supportLogs\"\n})\n\n// adding to permissionDAO\nconst permissionDAO = x['permissionDAO'];\npermissionDAO.put(newPaymentOpsPermission);\npermissionDAO.put(newSupportLogsPermission);\n\n\nconst updateSupportPermissions = async () => {\n  // grab current Support group\n  const groupDAO = x['groupDAO'];\n\n  const paymentOpsGroup = await groupDAO.find('payment-ops');\n\n  if ( ! paymentOpsGroup.permissions.includes(newPaymentOpsPermission) ){\n    // updating the support group array\n    paymentOpsGroup.permissions.push(newPaymentOpsPermission);\n\n    groupDAO.put(paymentOpsGroup);\n  }\n\n  if ( ! paymentOpsGroup.permissions.includes(newSupportLogsPermission) ){\n    // updating the support group array\n    paymentOpsGroup.permissions.push(newSupportLogsPermission);\n\n    groupDAO.put(paymentOpsGroup);\n  }\n}\n\nupdateSupportPermissions();\n\nprint(\"END 🔥\")"})
p({"class":"foam.nanos.script.Script","id":"OnboardingSetup","server":false,"status":1,"code":"var services = [\n    {\n        name: 'businessOnboardingDAO',\n        serve: true,\n        authenticate: true, // Remove this?\n        serviceScript: `\nreturn new net.nanopay.sme.onboarding.BusinessOnboardingDAO.Builder(x)\n  .setDelegate(new foam.dao.EasyDAO.Builder(x)\n                    .setAuthenticate(false)\n                    .setOf(net.nanopay.sme.onboarding.BusinessOnboarding.getOwnClassInfo())\n                    .setJournalType(foam.dao.JournalType.SINGLE_JOURNAL)\n                    .setJournalName(\"businessOnboardingDAO\")\n                    .build())\n  .build();\n        `,\n        client: '{\"of\":\"net.nanopay.sme.onboarding.BusinessOnboarding\"}'\n    }\n].map(o => foam.nanos.boot.NSpec.create(o, x));\n\nvar menus = [\n    {\n        id: 'onboarding',\n        label: 'Onboarding',\n        handler: {class:'foam.nanos.menu.SubMenu'}\n    },\n    {\n        parent: 'onboarding',\n        id: 'onboarding.business',\n        label: 'Business Onboarding',\n        handler: {\n            class:'foam.nanos.menu.DAOMenu',\n            daoKey: 'businessOnboardingDAO',\n            detailView: 'foam.u2.detail.SectionedDetailView'\n        }\n    }\n].map(o => foam.nanos.menu.Menu.create(o, x));\n\nPromise.all([].concat(\n    services.map(o => x['nSpecDAO'].put(o)),\n    menus.map(o => x['menuDAO'].put(o)),\n)).then(function() {\n    return x['groupDAO'].find('sme')\n}).then(function(g) {\n    if ( g.permissions.find(p => p.id == 'service.businessOnboardingDAO') ) return;\n    g.permissions.push(foam.nanos.auth.Permission.create({\n        id: 'service.businessOnboardingDAO'\n    }));\n    return x['groupDAO'].put(g);\n}).then(function() {\n    print('Done');\n});","output":"Done\n"})
p({"class":"foam.nanos.script.Script","id":"Add USD permission to existing Ablii users","description":"Add USD permission to existing Ablii users","code":"import foam.dao.DAO;\u000aimport foam.dao.ArraySink;\u000aimport foam.nanos.auth.User;\u000aimport foam.nanos.auth.Group;\u000aimport foam.nanos.auth.Permission;\u000aimport net.nanopay.model.Business;\u000aimport javax.security.auth.AuthPermission;\u000a\u000aString PERMISSION = \"currency.read.USD\";\u000a\u000aDAO businessDAO = (DAO) x.get(\"businessDAO\");\u000aDAO groupDAO = (DAO) x.get(\"groupDAO\");\u000a\u000abusinesses = businessDAO.select(new ArraySink()).getArray();\u000aint i;\u000a\u000afor ( Business business : businesses ) {\u000a  Group group = groupDAO.find(business.getBusinessPermissionId() + \".employee\");\u000a\u000a  if ( group.implies(x, new AuthPermission(PERMISSION)) ) {\u000a    print(\"Group \" + group.getId() + \" already has a permission that implies the one we're adding. Skipping.\");\u000a    continue;\u000a  }\u000a\u000a  Permission[] permissions = group.getPermissions();\u000a  Permission[] newPermissions = new Permission[permissions.length + 1];\u000a\u000a  for ( i = 0; i < permissions.length; i++ ) {\u000a    newPermissions[i] = permissions[i];\u000a  }\u000a\u000a  newPermissions[i] = new Permission.Builder(x).setId(PERMISSION).build();\u000a  group.setPermissions(newPermissions);\u000a  groupDAO.put(group);\u000a  print(\"Successfully added permission '\" + newPermissions[i].getId() + \"' to group \" + group.getId());\u000a}\u000a"})
p({"class":"foam.nanos.script.Script","id":"Count Accounting Users","description":"shows users connected to Xero & QBO","code":"import foam.mlang.sink.Count;\nimport foam.nanos.auth.User;\nimport net.nanopay.accounting.IntegrationCode;\nimport foam.dao.DAO;\nimport foam.dao.ArraySink;\n\nDAO userDAO = (DAO) x.get(\"localUserDAO\");\n\nArraySink xero = (ArraySink) userDAO.where(foam.mlang.MLang.EQ(User.INTEGRATION_CODE, IntegrationCode.XERO)).select(new ArraySink());\nprint(\"===== \" + xero.getArray().size() + \" users are connected to Xero =====\");\nfor ( Object user : xero.getArray()) {\n  print( ((User)user).getBusinessName() );\n}\n\nprint(\"\");\nprint(\"\");\n\nArraySink quickbooks = (ArraySink) userDAO.where(foam.mlang.MLang.EQ(User.INTEGRATION_CODE, IntegrationCode.QUICKBOOKS)).select(new ArraySink());\nprint(\"===== \" + xero.getArray().size() + \" users are connected to QuickBooks =====\");\nfor ( Object user : quickbooks.getArray()) {\n  print( ((User)user).getBusinessName() );\n}"})
p({"class":"foam.nanos.script.Script","id":"Update Accounting Permissions","enabled":false,"description":"Remove xero perms/ add quickbooks perms to sme. Add xero perms to old business that used xero before.","code":"import foam.mlang.sink.Count;\nimport foam.nanos.auth.User;\nimport net.nanopay.accounting.IntegrationCode;\nimport foam.dao.DAO;\nimport foam.dao.ArraySink;\nimport foam.nanos.auth.Group;\nimport foam.nanos.auth.Permission;\nimport foam.core.X;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\nvoid addPermToGroup(groupID){\n\nif ( groupID.endsWith(\".admin\") ) {\ngroupID = groupID.substring(0, groupID.lastIndexOf(\".\"));\ngroupID += \".employee\";\n} else {\nprint(\"Unexpected groupID: \"+groupID);\nreturn;\n}\nString[] permsToAdd = {\n\"service.xeroService\"\n};\n\n// =================================================================================\n\n// grabbing the group's permissions property and permissionDAO\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\nif ( group == null ) {\nprint(\"Group not found: \" + groupID);\nprint(\"\");\nreturn;\n}\ngroupPerms = group.permissions;\npermissionDAO  = x.get(\"permissionDAO\");\n\n// FOR DEBUGGING\nprint(\"START ADD XERO PERM TO GROUP \");\nprint(\"************************\");\nprint(\"GroupID: \" + groupID);\nprint(\"\");\nprint(\"CurrentPermissions: \");\nprint(groupPerms);\nprint(\"\");\nprint(\"PermissionsToAdd: \");\nprint(permsToAdd);\nprint(\"\");\nprint(\"\");\n\n/**\n* we place the following loop at the top in order to act as a fail safe\n* if for some reason only the \"payment-ops\" group permissions array previously had the requested permissions\n* but the PermissionDAO did not get updated with those same permissions\n* we will then add the requested permissions into the PermissionsDAO only if they are unique\n* this is because later on in the script\n* we end the script if \"payment-ops\" group permissions array already has all the requested permissions\n* that is why we are updating the permissionsDAO first\n*/\nfor ( i = 0; i < permsToAdd.length; i++ ){\n/**\n*  ! NOTE: currently commenting out the lowercasifying until \n*  ! lowercase permission standardizations are made\n*  ! currently service permissions are all camel-cased\n*/\n// here we will also lowercasify the permissions in the array as well while we make this check\n// permsToAdd[i] = permsToAdd[i].toLowerCase();\n\ncurrentPermId = permsToAdd[i];\nif ( permissionDAO.find(currentPermId) == null ) permissionDAO.put(new Permission(currentPermId, \"\"));\n} \n\n/**\n* from here on out we will be dealing solely with the \"payment-ops\" group permissions' property\n* transforming the primitive array into just a set\n* because as we're deep cloning we can check if there are any duplicates\n* and then just pop them off the set\n*/\nSet permsToAddSet = new HashSet();\nfor ( i = 0; i < permsToAdd.length; i++ ) {\npermsToAddSet.add(permsToAdd[i]);\n}\n\n/**\n* we use an ArrayList instead of a primitive array because\n* we don't know the exact length of the final array if there are duplicates\n*/\nList newPermissions = new ArrayList();\n\nfor ( i = 0; i < groupPerms.length; i++ ) {\ncurrentPerm = groupPerms[i];\n\n// 1. deep clone original permissions to new arrayList\nnewPermissions.add(new Permission(currentPerm.id, currentPerm.description));\n\n// 2. check if permsToAdd is asking for this permission then pop it off because will already have been created\nif ( permsToAddSet.contains(currentPerm.id) ) permsToAddSet.remove(currentPerm.id);\n}\n\n// if permsToAddSet is empty, that means theres nothing to add\n// we can end the script here\nif ( permsToAddSet.isEmpty() ) {\nprint(\"Ending script here because the \" + groupID + \" group already has all the requested permissions\");\nprint(\"************************\");\nprint(\"END\");\nreturn;\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"OriginalPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// here we will iterate through the remaining permsToAdd and place them in the newPermissions arraylist\nfor ( perm : permsToAddSet ) {\ncurrentPermission = new Permission(perm, \"\");\nnewPermissions.add(currentPermission);\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"NewPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// making a deep conversion of the newPermissions ArrayList to a primitive array\nPermission[] newPermissionsArray = new Permission[newPermissions.size()];\nfor ( i = 0; i < newPermissionsArray.length; i++ ) {\nnewPermissionsArray[i] = new Permission(newPermissions.get(i).id, newPermissions.get(i).description);\n}\n\n// set newPermissionsArray as new property\ngroup.setPermissions(newPermissionsArray);\n\n// put modified group back into the groupDAO\ngroupDAO.put(group);\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(groupID + \"Group Permissions\");\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\nprint(groupPerms);\nprint(\"=======================\");\nprint(\"\");\nprint(\"************************\");\nprint(\"END\");\n}\n\n\n// Add Xero permission to nanopay ablii group\naddPermToGroup(\"nanopaycorporation1357.admin\");\n\n// Find users that use xero and add the permission to use xero to their group\n\nDAO userDAO = (DAO) x.get(\"localUserDAO\");\nArraySink xero = (ArraySink) userDAO.where(foam.mlang.MLang.EQ(User.INTEGRATION_CODE, IntegrationCode.XERO)).select(new ArraySink());\nprint(\"===== \" + xero.getArray().size() + \" users are connected to Xero =====\");\nfor ( Object user : xero.getArray()) {\n  print( ((User)user).getBusinessName() );\n  addPermToGroup( ((User)user).getGroup() );\n}\n\n\n\n// Remove xero permission from SME\n// ==================================================================================\n\ngroupID = \"sme\";\nString[] permsToRemove = {\n\"service.run.xero\"\n};\n\n// =================================================================================\n// grabbing the group's permissions property and permissionDAO\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\npermissionDAO  = x.get(\"permissionDAO\");\n\n// FOR DEBUGGING\nprint(\"STARTING REMOVE XERO PERMISSION FROM SME\");\nprint(\"************************\");\nprint(\"GroupID: \" + groupID);\nprint(\"\");\nprint(\"CurrentPermissions: \");\nprint(groupPerms);\nprint(\"\");\nprint(\"PermissionsToRemove\");\nprint(permsToRemove);\nprint(\"\");\nprint(\"\");\n\n\nfor ( i = 0; i < permsToRemove.length; i++ ){\n// here we will also lowercasify the permissions in the array as well while we make this check\npermsToRemove[i] = permsToRemove[i].toLowerCase();\n} \n\n\nList newPermissions = new ArrayList();\nfor ( i = 0; i < groupPerms.length; i++ ) {\ncurrentPerm = groupPerms[i];\nif ( ! Arrays.asList(permsToRemove).contains(currentPerm.id) ) {\nnewPermissions.add(new Permission(currentPerm.id, currentPerm.description));\n}\n}\n\n// making a deep conversion of the newPermissions ArrayList to a primitive array\nPermission[] newPermissionsArray = new Permission[newPermissions.size()];\nfor ( i = 0; i < newPermissionsArray.length; i++ ) {\nnewPermissionsArray[i] = new Permission(newPermissions.get(i).id, newPermissions.get(i).description);\n}\n\n// set newPermissionsArray as new property\ngroup.setPermissions(newPermissionsArray);\n\n// put modified group back into the groupDAO\ngroupDAO.put(group);\n\n// FOR DEBUGGING\nprint(\"=======================\");\nprint(groupID + \"Group Permissions\");\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\nprint(groupPerms);\nprint(\"=======================\");\nprint(\"\");\nprint(\"************************\");\nprint(\"END\");\n\n\n// Add Quickbooks permission to sme\n\nString groupID = \"sme\";\nString[] permsToAdd = {\n\"service.quickbooksService\"\n};\n\n// =================================================================================\n\n// grabbing the group's permissions property and permissionDAO\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\nif ( group == null ) {\nprint(\"Group not found: \" + groupID);\nprint(\"\");\nreturn;\n}\ngroupPerms = group.permissions;\npermissionDAO  = x.get(\"permissionDAO\");\n\n// FOR DEBUGGING\nprint(\"START ADDING QUICKBOOKS PERM TO SME\");\nprint(\"************************\");\nprint(\"GroupID: \" + groupID);\nprint(\"\");\nprint(\"CurrentPermissions: \");\nprint(groupPerms);\nprint(\"\");\nprint(\"PermissionsToAdd: \");\nprint(permsToAdd);\nprint(\"\");\nprint(\"\");\n\n/**\n* we place the following loop at the top in order to act as a fail safe\n* if for some reason only the \"payment-ops\" group permissions array previously had the requested permissions\n* but the PermissionDAO did not get updated with those same permissions\n* we will then add the requested permissions into the PermissionsDAO only if they are unique\n* this is because later on in the script\n* we end the script if \"payment-ops\" group permissions array already has all the requested permissions\n* that is why we are updating the permissionsDAO first\n*/\nfor ( i = 0; i < permsToAdd.length; i++ ){\n/**\n*  ! NOTE: currently commenting out the lowercasifying until \n*  ! lowercase permission standardizations are made\n*  ! currently service permissions are all camel-cased\n*/\n// here we will also lowercasify the permissions in the array as well while we make this check\n// permsToAdd[i] = permsToAdd[i].toLowerCase();\n\ncurrentPermId = permsToAdd[i];\nif ( permissionDAO.find(currentPermId) == null ) permissionDAO.put(new Permission(currentPermId, \"\"));\n} \n\n/**\n* from here on out we will be dealing solely with the \"payment-ops\" group permissions' property\n* transforming the primitive array into just a set\n* because as we're deep cloning we can check if there are any duplicates\n* and then just pop them off the set\n*/\nSet permsToAddSet = new HashSet();\nfor ( i = 0; i < permsToAdd.length; i++ ) {\npermsToAddSet.add(permsToAdd[i]);\n}\n\n/**\n* we use an ArrayList instead of a primitive array because\n* we don't know the exact length of the final array if there are duplicates\n*/\nList newPermissions = new ArrayList();\n\nfor ( i = 0; i < groupPerms.length; i++ ) {\ncurrentPerm = groupPerms[i];\n\n// 1. deep clone original permissions to new arrayList\nnewPermissions.add(new Permission(currentPerm.id, currentPerm.description));\n\n// 2. check if permsToAdd is asking for this permission then pop it off because will already have been created\nif ( permsToAddSet.contains(currentPerm.id) ) permsToAddSet.remove(currentPerm.id);\n}\n\n// if permsToAddSet is empty, that means theres nothing to add\n// we can end the script here\nif ( permsToAddSet.isEmpty() ) {\nprint(\"Ending script here because the \" + groupID + \" group already has all the requested permissions\");\nprint(\"************************\");\nprint(\"END\");\nreturn;\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"OriginalPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// here we will iterate through the remaining permsToAdd and place them in the newPermissions arraylist\nfor ( perm : permsToAddSet ) {\ncurrentPermission = new Permission(perm, \"\");\nnewPermissions.add(currentPermission);\n}\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(\"NewPermissions\");\nprint(newPermissions);\nprint(\"=======================\");\nprint(\"\");\n\n// making a deep conversion of the newPermissions ArrayList to a primitive array\nPermission[] newPermissionsArray = new Permission[newPermissions.size()];\nfor ( i = 0; i < newPermissionsArray.length; i++ ) {\nnewPermissionsArray[i] = new Permission(newPermissions.get(i).id, newPermissions.get(i).description);\n}\n\n// set newPermissionsArray as new property\ngroup.setPermissions(newPermissionsArray);\n\n// put modified group back into the groupDAO\ngroupDAO.put(group);\n\n// FOR DEBUGGING\nprint(\"\");\nprint(\"=======================\");\nprint(groupID + \"Group Permissions\");\ngroupDAO = x.get(\"groupDAO\");\ngroup = groupDAO.find(groupID);\ngroupPerms = group.permissions;\nprint(groupPerms);\nprint(\"=======================\");\nprint(\"\");\nprint(\"************************\");\nprint(\"END\");\n"})
p({"class":"foam.nanos.script.Script","id":"Generate Model Documentation","description":"Generates documentation for all properties on a model","enabled":true,"server":false,"code":"var generateMarkdownForClasses = foam.nanos.auth.User;\n\nprintHelpString(generateMarkdownForClasses);\n\nfunction printHelpString(opt_name) {\n  log( '| Name               | Axiom Type         |Documentation                                               | Class                                                           |');\n  log( '|--------------------|--------------------|------------------------------------------------------------|-----------------------------------------------------------------|');\n\n  printHelpLineString(opt_name);\n};\n\nfunction printHelpLineString(opt_name) {\n\n  var axiomMap_ = opt_name.axiomMap_;\n  for ( var key in axiomMap_ ) {\n    \n    // Get the axiom and field type\n    var axiom = axiomMap_[key];\n    var axiomTypeField = axiom.cls_ ? axiom.cls_.name : 'anonymous';\n\n    // Only print valid axioms\n    if ( axiom.name != undefined && axiom.name.length != 0 && axiom.name != 'FObject' ) {\n      \n      // Check for properties\n      if ( foam.core.Property.isInstance(axiom) ) {\n\n        // Change the delimiter on the name if the property is not one of the base class properties\n        var delim = axiom.forClass_ === generateMarkdownForClasses.id ? '***':'---';\n\n        // Log the  property\n        log( '|' + foam.String.pad(delim + axiom.name + delim, 20) +\n             '|' + foam.String.pad(axiom.cls_ ? axiom.cls_.name : 'anonymous', 20) +\n             '|' + foam.String.pad(axiom.documentation ? axiom.documentation : ' ', axiom.documentation && axiom.documentation.length > 60 ? axiom.documentation.length : 60) +\n             '|' + foam.String.pad(axiom.forClass_, 65) +\n             '|');\n\n        // Recursively print out the properties of FObjectProperty objects\n        if ( axiomTypeField == 'FObjectProperty' )\n          printHelpLineString(axiom.of);  /**/\n      }\n    }\n  }\n  return '';\n}\n"})
p({"class":"foam.nanos.script.Script","id":"DAO Security Test","description":"DAO Security Testl","enabled":true,"server":true,"code":"import nanopay.src.net.nanopay.scripts.DAOSecurityTest.*;\nString testBody = \"nanopay/src/net/nanopay/scripts/DAOSecurityTest/test_body1.json\";\nString serviceFile = \"nanopay/src/services.jrl\";\nString results = DAOSecurityTest.runTest(testBody, serviceFile);\nprint(results);"})
p({"class":"foam.nanos.script.Script","id":"addComplianceReadToSME","code":"import foam.core.X;\nimport foam.dao.DAO;\nimport foam.nanos.auth.AuthService;\nimport foam.nanos.auth.Group;\nimport foam.nanos.auth.Permission;\nimport java.security.BasicPermission;\n\ngroupDAO = ((DAO) x.get(\"localGroupDAO\")).inX(x);\nauth = (AuthService) x.get(\"auth\");\n\ngroup = (Group) groupDAO.find(\"sme\");\n\nX groupCtx = x.put(\"group\", group);\n\nString[] permissionsToAdd = {\n  \"business.ro.compliance\",\n\"user.ro.compliance\"\n};\n\nfor ( String permissionId : permissionsToAdd ) {\n  if ( auth.check(groupCtx, permissionId) ) {\n    print(\"Already has \" + permissionId + \".\");\n  } else {\n    print(\"Need to add \" + permissionId + \".\");\n    Permission[] currentPermissions = group.getPermissions();\n    Permission[] newPermissions = new Permission[currentPermissions.length + 1];\n    for ( int i = 0; i < currentPermissions.length; i++ ) {\n      newPermissions[i] = currentPermissions[i];\n    }\n    newPermissions[currentPermissions.length] = new Permission(permissionId, \"\");\n    group.setPermissions(newPermissions);\n    print(\"Added \" + permissionId + \".\");\n  }\n}\n\ngroupDAO.put(group);","output":""})
p({"class":"foam.nanos.script.Script","id":"LiquidLiquiditySettingsTest","description":"To test out liquidity settings on liquid","server":false,"code":"/**\n * TITLE: LiquidLiquiditySettingsTest\n * DESCRIPTION: To test out liquidity settings on liquid\n */\n// ==================================================================================\n\nconst main = async () => {\n  // grabbing DAOs\n  const accountDAO = x['accountDAO'];\n  const transactionDAO = x['transactionDAO'];\n  const liquiditySettingsDAO = x['liquiditySettingsDAO'];\n  const MLang = foam.mlang.ExpressionsSingleton.create();\n\n  // grabbing user id\n  const userId = x.user.id;\n  const fromName = 'Main Virtual [4][0][1]';\n  const toName = 'Main Virtual [1][0][1]';\n  const liquiditySettingName = 'Notify and Auto';\n  const rootName = 'Main Root Shadow [0][0][0]';\n\n  // grab the root id of the main tree\n\n  const rootAccount = await accountDAO.limit(1).where(MLang.EQ(net.nanopay.account.Account.NAME, rootName)).select();\n\n  const lowLiquidity = {\n    enabled: true,\n    rebalancingEnabled: true,\n    threshold: 1,\n    resetBalance: 5000000,\n    pushPullAccount: rootAccount.array[0].id\n  }\n  \n  /**\n   * Essentially after this, the fromAccount should trigger a lowLiquidityThreshold and have its balance reset to $50,000 if enabled above\n   * the toAccount should trigger a highLiquidityThreshold and have its balance reset to $500,0000\n   */\n\n  const newLiquiditySettingArray = await liquiditySettingsDAO.limit(1).where(MLang.EQ(net.nanopay.liquidity.LiquiditySettings.NAME, liquiditySettingName)).select();\n\n  const newLiquiditySetting = newLiquiditySettingArray.array[0];\n\n  newLiquiditySetting.lowLiquidity = lowLiquidity;\n\n  // update the notify and auto setting in the DAO\n  await liquiditySettingsDAO.put(newLiquiditySetting);\n\n  // 1. grab the from account\n  // fromAccount = 204\t\tMain Virtual [4][0][1]\tDigitalAccount\tCAD\t$579,000.00\t\n  const fromAccount = await accountDAO.limit(1).where(MLang.EQ(net.nanopay.account.Account.NAME, fromName)).select();\n\n  // 2. grab the to account\n  // toAccount = 189\t\tMain Virtual [1][0][1]\tDigitalAccount\tCAD\t$586,000.00\n  const toAccount = await accountDAO.limit(1).where(MLang.EQ(net.nanopay.account.Account.NAME, toName)).select();\n\n  // 3. create a transaction of the entire balance from\n  const transaction = net.nanopay.tx.model.Transaction.create({\n    sourceAccount: fromAccount.array[0].id,\n    destinationAccount: toAccount.array[0].id,\n    amount: await fromAccount.array[0].findBalance(x),\n    createdBy: userId,\n    payerId: userId,\n    payeeId: userId\n  }, x);\n\n  await transactionDAO.put(transaction);\n\n  print('FIN');\n}\n\nmain();"})
p({"class":"foam.nanos.script.Script","id":"Network Transport for EmailMessages", "code":"\nimport foam.nanos.notification.email.EmailService;\nimport foam.nanos.notification.email.SMTPEmailService;\nimport foam.nanos.notification.email.ProxyEmailService;\n\n\nProxyEmailService pes = x.get(\"email\"); \nEmailService es = new SMTPEmailService.Builder(x)\n.setHost(\"smtp.gmail.com\")\n.setPort(\"587\")\n.setAuthenticate(true)\n.setStarttls(true)\n.setUsername(\"nanopay.email@gmail.com\")\n.setPassword(\"Em@1l53nd3r\")\n.build(); \n\npes.setDelegate(es);\nprint(\"done\");","output":""})
p({"class":"foam.nanos.script.Script","id":"setupAbliiUsers","status":2,"code":"import foam.nanos.auth.User;\nimport foam.mlang.MLang;\nimport net.nanopay.model.Business;\nimport foam.nanos.auth.Address;\nimport net.nanopay.admin.model.ComplianceStatus;\nimport net.nanopay.admin.model.AccountStatus;\nimport net.nanopay.bank.BankAccountStatus;\nimport net.nanopay.Account;\nimport net.nanopay.bank.BankAccount;\nimport net.nanopay.bank.CABankAccount;\nimport foam.nanos.auth.UserUserJunction;\n\naccountDAO = x.get(\"accountDAO\");\nagentJunctionDAO = x.get(\"agentJunctionDAO\");\nbusinessDAO = x.get(\"businessDAO\");\nregionDAO = x.get(\"regionDAO\");\nsmeBusinessRegistrationDAO = x.get(\"smeBusinessRegistrationDAO\");\nuserDAO = x.get(\"userDAO\");\n\nusers = userDAO.orderBy(User.ID).select().getArray();\ni = users.get(users.size() - 1).getId() + 1;\n\n// emails are in order of {admin1, employee1, admin2, employee2, ...}\n// the emails without corresponding passwords will have it set to passwords[0]\nString[] emails = {\"user\"+i+\"@email.com\", \"employee\"+i+\"@email.com\", \"user\"+(i+2)+\"@email.com\", \"employee\"+(i+2)+\"@email.com\"};\nString[] passwords = {\"AbliiTestUser\"}; \n\naddress = new Address();\naddress.setCountryId(\"CA\");\naddress.setStreetName(\"Avenue Rd\");\naddress.setStreetNumber(\"123\");\naddress.setPostalCode(\"M1M1M1\");\naddress.setCity(\"Toronto\");\naddress.setRegionId(regionDAO.find(\"ON\").getCode());\n\nbirthday = new GregorianCalendar(2000, 1, 1).getTime();\n\nfor(int j = 0; j < emails.length; j+=2) {\n    print(\"\\nCompany \"+(i+j));\n    user = new User();\n    user.setFirstName(\"Test\");\n    user.setLastName(\"Admin\");\n    user.setEmail(emails[j]);\n    user.setDesiredPassword(passwords.length<j+1?passwords[0]:passwords[j]);\n    user.setGroup(\"sme\");\n    user.setAddress(address);\n    user.setType(\"Business\");\n    user.setOrganization(\"Company \"+(i+j));\n    user.setBusinessName(\"Company \"+(i+j));\n    user.setLanguage(\"en\");\n    user.setBirthday(birthday);\n    user.setBusinessAddress(address);\n    user.setEnabled(true);\n    user.setLoginEnabled(true);\n    user.setEmailVerified(true);\n    user.setEmailVerified(true);\n    smeBusinessRegistrationDAO.put(user);\n\n    business = businessDAO.where(foam.mlang.MLang.EQ(Business.EMAIL, user.getEmail())).select().getArray().get(0);\n    business = business.fclone();\n    business.setStatus(AccountStatus.ACTIVE);\n    business.setBusinessAddress(address);\n    business.setOnboarded(true);\n    business.setCompliance(ComplianceStatus.PASSED);\n    try {\n        businessDAO.put(business);\n    } catch(Exception e) {\n    }\n\n    account = new CABankAccount();\n    account.setName(\"testAccount\"+(i+j));\n    account.setBranchId(\"12345\");\n    account.setInstitutionNumber(\"004\");\n    account.setAccountNumber(\"1232142113\");\n    account.setStatus(BankAccountStatus.VERIFIED);\n    account.setOwner(business.getId());\n    account.setParent(business.getId());\n    account.setAddress(address);\n\n    accountDAO.put(account);\n\n    print(\"ADMIN CREATED :\\n . \"+user.getEmail() + \"\\n . \" + (passwords.length<j+1?passwords[0]:passwords[j]));\n\n    admin = user;\n\n    user = new User();\n    user.setEnabled(true);\n    user.setLoginEnabled(true);\n    user.setFirstName(\"Test\");\n    user.setLastName(\"Employee\");\n    user.setBusinessAddress(address);\n    user.setOrganization(admin.getOrganization());\n    user.setGroup(admin.getGroup());\n    user.setEmail(emails[j+1]);\n    user.setEmailVerified(true);\n    user.setDesiredPassword(passwords.length<j+2?passwords[0]:passwords[j+1]);\n    user.setStatus(AccountStatus.ACTIVE);\n    userDAO.put(user);\n\n    UserUserJunction junction = new UserUserJunction();\n    junction.setGroup(admin.getGroup());\n    junction.setSourceId(user.getId());\n    junction.setTargetId(business.getId());\n    agentJunctionDAO.put(junction);\n\n    print(\"EMPLOYEE CREATED :\\n . \"+user.getEmail() + \"\\n . \" + (passwords.length<j+2?passwords[0]:passwords[j+1]));\n}\n\n","output":""})
p({"class":"foam.nanos.script.Script","id":"testKotakPayment","description":"submit a kotak payment","code":"import net.nanopay.kotak.Test;\nimport net.nanopay.kotak.KotakService;\nimport net.nanopay.kotak.KotakPaymentProcessor;\n\nKotakService kotakService = new KotakService(x);\n\nTest test = new Test();\n\n// kotakService, msgSource, clientCode, myProdCode, payMode, senderAccountNo, txnAmnt, beneAcctNo, beneName,\n// IFSCCode, remitterName, beneACType, remitterAddress, remitterAcNo, remitPurpose\n\n// testing\ntest.paymentTest(kotakService, \"NANOPAY\", \"TESTAPI\", \"NETPAY\", \"IMPS\", \"9411128990\", 500, \"9111175690\", \"HELLO API\", \n                 \"ICIC0000361\", \"NANOPAY\", \"SAVING\", \"905 King St W Suite 300\", \"9411128990\", \"TRANSFER_FROM_SELF\");\n\nprint(\"paymentMessageId: \" + test.paymentMessageId);\nprint(\"paymentResponseStatusCode: \" + test.paymentResponseStatusCode);\nprint(\"paymentResponseStatusRem: \" + test.paymentResponseStatusRem);\nprint(\"done\");"})
p({"class":"foam.nanos.script.Script","id":"testKotakStatusChecking","description":"check the status of a kotak payment","code":"import net.nanopay.kotak.Test;\nimport net.nanopay.kotak.KotakService;\nimport net.nanopay.kotak.KotakPaymentProcessor;\n\nKotakService kotakService = new KotakService(x);\nTest test = new Test();\n\n// kotakService, paymentMessageId, msgSrc, clientCode\n// testing\ntest.reversalTest(kotakService, \"7ea9bfd303e04312\", \"NANOPAY\", \"TESTAPI\");\n\nprint(\"transactionStatusCode: \" + test.transactionStatusCode);\nprint(\"transactionStatusDesc: \" + test.transactionStatusDesc);\nprint(\"done\");"})
