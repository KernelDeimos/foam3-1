p({"class":"foam.nanos.script.Script","id":"GenerateLiquidDemoData","description":"Generates a bunch of fake data suitable for demoing the liquid application for the current user.","server":false,"code":"/**\n * TITLE: LiquidDevEnvJs\n * DESCRIPTION: To set up a deterministic liquid dev environment\n */\n// ==================================================================================\n\n/**\n * The total amount of child sets at a given level should be equal to the amount of characters (AKA nodes)\n * at the previous level, discounting the amount\n *\n * i.e. Level 3 should have 4 child sets give there were 4 characters (nodes) in Level 2\n */\n\n//===========================================================================================================\n//\n// â”€â”€â”€ CUSTOMIZE HERE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n//\n\n/**\n * Defining the Tree\n * ? i is the tree level (with 0 as the root)\n * ? j is the child set\n * ? k is the child node\n *\n * Each child set j corresponds to the jth node in the previous level\n * Node order goes from left to right, top to bottom, as if you were to iterate in order over a 2-D array\n *\n * For example at level 2, the 4th node is [2][2][1] = 'v'\n * That means that the children of [2][2][1] is in level 3 at [3][4] = ['a', 'v']\n *\n * !IMPORTANT! You will need to make sure that the number of childsets in the next\n * !IMPORTANT! level corresponds to the number of nodes in the current level\n * !IMPORTANT! You can currently create a max 8 trees, but you can increase this by adding more bank information numbers\n * !IMPORTANT! at the end of this section\n *\n * TODO: Add validation for this\n *\n */\n\n// an array of trees for you to input\nconst trees = [\n  {\n    name: 'Main',\n    treeTypes: [\n      [ // level 0\n        ['s']\n      ],\n      [ // level 1: 1 child sets\n        ['a', 'v', 'v']\n      ],\n      [ // level 2: 3 child sets\n        ['a', 'v'],\n        [],\n        ['a', 'v']\n      ],\n      [ // level 3: 4 child sets\n        ['a', 'v'],\n        ['a', 'v'],\n        ['a', 'v'],\n        ['a', 'v']\n      ],\n      [ // level 4: 8 child sets\n        ['a', 'v', 'v'],\n        [],\n        ['a'],\n        [],\n        ['a'],\n        [],\n        [],\n        ['a', 'v', 'v']\n      ]\n    ]\n  },\n\n  {\n    name: 'Other',\n    treeTypes: [\n      [\n        ['s'],\n      ],\n      [\n        ['a', 'v'],\n      ]\n    ]\n  }\n];\n\n// the initialization amount to be transferred from BankAccount to ShadowAccount\nconst rootAccountBalance = [10000000000];\n\nconst accountBalanceSequence = [10000000, 50000000, 60000000, 40000000, 20000000];\nconst accountCurrencySequence = ['CAD'];\n\n/**\n * Liquidity Settings Setup\n * Define the low liquidity threshold further below\n */\nconst liquiditySettingsNotifyOnly = {\n  name: 'Notify Only',\n  cashOutFrequency: net.nanopay.util.Frequency.PER_TRANSACTION,\n  highLiquidity: {\n    enabled: true,\n    threshold: 100000000\n  }\n};\n\nconst liquiditySettingsNotifyAuto = {\n  name: 'Notify and Auto',\n  cashOutFrequency: net.nanopay.util.Frequency.PER_TRANSACTION,\n  highLiquidity: {\n    enabled: true,\n    rebalancingEnabled: true,\n    threshold: 100000000,\n    resetBalance: 50000000\n  }\n\n  // adding low liquidity here will mess things up, this is because the accounts get created and start at 0\n  // if we do include low liquidity then we have to await for every account transaction to be completed which\n  // will end up taking a long time, to test lowLiquidity, add it manually or run the LiquidLiquiditySettingsTest script\n};\n\n/**\n * You can enter the sequence here  with 'no' denoting Notify Only and 'na' with Notify and Auto Transactions\n * As the liquidity settings  get created, the String values in the array below we be exchanged for their IDs\n */\nlet liquiditySettingsSequence = ['no', 'na', null];\n\n/**\n * TRANSACTIONS SETUP\n * ! Specific transaction accounts need to be set up  below in the transaction section\n * ! This is because the accounts need to be created first\n */\n\nconst numberOfBulkTransactions = 1000;\n\nconst transactionAmountSequence = [100000, 150000, 200000, 250000, 300000, 50000]\n\n// the times for scheduled transactions\nconst scheduledTimeSoonMinutes = 1;\nconst scheduledTimeLaterMinutes = 5;\n\n// bank information numbers since they all need to be distinct\n// currently with below can create 8 trees, but if you add to all of them then you can increase that number\nconst accountNumbers = [\n  '1234567',\n  '2134567',\n  '3124567',\n  '1324567',\n  '2314567',\n  '3214567',\n  '3241567',\n  '2341567'\n];\n\nconst branchIds = [\n  '12345',\n  '21345',\n  '31245',\n  '13245',\n  '23145',\n  '32145',\n  '32415',\n  '23415'\n];\n\nconst institutionNumbers = [\n  '123',\n  '213',\n  '312',\n  '132',\n  '231',\n  '321',\n  '456',\n  '567',\n];\n\n//===========================================================================================================\n\nconst main = async () => {\n  print('################################');\n  print('================================');\n  print('STARTING SCRIPT ðŸ’ªðŸ’ªðŸ’ª');\n  print('================================');\n  print('################################');\n\n  print();\n\n  print(\"[                                ] 0% ðŸ‘Œ\")\n\n  // add a tree node and bank account property\n  trees.forEach(tree => {\n    tree.treeNodes = tree.treeTypes.slice(0);\n  });\n\n  const MLang = foam.mlang.ExpressionsSingleton.create();\n  const promises = [];\n\n  // setting pointers for account data\n  let accountNumberPointer = 0;\n  let branchIdPointer = 0;\n  let institutionNumberPointer = 0;\n\n  // extract the user id to make as owner\n  userId = x[\"user\"].id\n\n  //\n  // â”€â”€â”€ ACCOUNTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  //\n\n  // grab accountDAO\n  const accountDAO = x['accountDAO'];\n  const transactionDAO = x['transactionDAO'];\n  const liquiditySettingsDAO = x['liquiditySettingsDAO'];\n\n\n  for (let i = 0; i < trees.length; i++) {\n    const bankAccountModel = net.nanopay.bank.CABankAccount.create({\n      name: `${trees[i].name} Associated Bank CAD`,\n      owner: userId,\n      accountNumber: `${accountNumbers[accountNumberPointer++]}`,\n      branchId: `${branchIds[branchIdPointer++]}`,\n      institutionNumber: `${institutionNumbers[institutionNumberPointer++]}`,\n      status: net.nanopay.bank.BankAccountStatus.VERIFIED,\n    }, x)\n\n    trees[i].bankAccount = await accountDAO.put(bankAccountModel);\n  }\n\n  //\n  // â”€â”€â”€ LIQUIDITY SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  //\n\n  print(\"[==========                      ] 25%\")\n  // set the liquiditySettingsNotifyOnly and liquiditySettingsNotifyAuto to the current user\n  liquiditySettingsNotifyOnly.userToEmail = userId;\n  liquiditySettingsNotifyAuto.userToEmail = userId;\n\n  const liquiditySettingsNotifyOnlyModel = net.nanopay.liquidity.LiquiditySettings.create(liquiditySettingsNotifyOnly, x);\n\n  // after the put we just want to extract the id\n  const liquiditySettingsNotifyOnlyId = (await liquiditySettingsDAO.put(liquiditySettingsNotifyOnlyModel)).id;\n\n  // filter through old array and replace the string with a model\n  liquiditySettingsSequence = liquiditySettingsSequence.map(value => {\n    if (value === 'no') return liquiditySettingsNotifyOnlyId;\n    return value;\n  })\n\n  print(\"[==============                  ] 40%\")\n\n  // seed root accounts and upload the auto transaction setting\n  let accountCurrencyPointer = 0;\n  let liquiditySettingsPointer = 0;\n\n  for (let i = 0; i < trees.length; i++) {\n    let rootAccount;\n    /**\n     * if the primary root, then we will need to make it also\n     * the LiquiditySettings Notfy And Auto Transaction account\n     */\n    if (i === 0 || trees[i].name.toLowerCase() === 'main') {\n      rootAccount = net.nanopay.account.ShadowAccount.create({\n        name: `${trees[i].name} Root Shadow [0][0][0]`,\n        owner: userId,\n        denomination: accountCurrencySequence[0],\n        liquiditySetting: liquiditySettingsSequence[0],  // notify only\n        bank: trees[i].bankAccount.id\n      }, x)\n\n      // grab and save the roots\n      trees[i].treeNodes[0][0][0] = await accountDAO.put(rootAccount);\n\n      // create the notify and auto rule\n      // make the push/pull account be the root\n      liquiditySettingsNotifyAuto.highLiquidity.pushPullAccount = trees[i].treeNodes[0][0][0].id;\n\n      // there is a bug with lowLiquidity upon creation of an account\n      // liquiditySettingsNotifyAuto.lowLiquidity.pushPullAccount = trees[i].treeNodes[0][0][0].id;\n\n      // upload the notify and auto into the DAO\n      const liquiditySettingsNotifyAutoModel = net.nanopay.liquidity.LiquiditySettings.create(liquiditySettingsNotifyAuto, x);\n\n      // after the put we just want to extract the id\n      const liquiditySettingsNotifyAutoId = (await liquiditySettingsDAO.put(liquiditySettingsNotifyAutoModel)).id;\n\n      // filter through old array and replace the string with a model\n      liquiditySettingsSequence = liquiditySettingsSequence.map(value => {\n        if (value === 'na') return liquiditySettingsNotifyAutoId;\n        return value;\n      })\n    } else {\n      rootAccount = net.nanopay.account.ShadowAccount.create({\n        name: `${trees[i].name} Root Shadow [0][0][0]`,\n        owner: userId,\n        denomination: accountCurrencySequence[accountCurrencyPointer++],\n        liquiditySetting: liquiditySettingsSequence[0],\n        bank: trees[i].bankAccount.id\n      }, x)\n      trees[i].treeNodes[0][0][0] = await accountDAO.put(rootAccount);\n\n      // resetting the pointers to the beginning of the array\n      if (accountCurrencyPointer >= accountCurrencySequence.length) accountCurrencyPointer = 0;\n      if (liquiditySettingsPointer >= liquiditySettingsSequence.length) liquiditySettingsPointer = 0;\n    }\n\n    const transferStartData = {\n      sourceAccount: trees[i].bankAccount.id,\n      destinationAccount: trees[i].treeNodes[0][0][0].id,\n      amount: rootAccountBalance[0],\n      createdBy: userId,\n      payerId: userId,\n      payeeId: userId,\n      completionDate: currentDate,\n    }\n\n    // seeding funds into the root shadow accounts\n    const transferStartModel = net.nanopay.tx.model.Transaction.create(transferStartData, x);\n\n    // first we need the initial transaction which is auto set to pending for CASH-IN\n    const transferStartInstance = await transactionDAO.put(transferStartModel);\n\n    const transferEndInstance = transferStartInstance;\n    transferEndInstance.status = net.nanopay.tx.model.TransactionStatus.COMPLETED;\n\n    // now we can upload the completed transaction for CASH-IN\n    await transactionDAO.put(transferEndInstance);\n  }\n\n  // building the account trees for each account\n  for (let t = 0; t < trees.length; t++) {\n    let accountBalancePointer = 0;\n    let accountCurrencyPointer = 0;\n    let liquiditySettingsPointer = 0;\n\n    // i is the level\n    // j is the child set\n    // k is the child node\n    for (let i = 0; i < trees[t].treeTypes.length - 1; i++) {\n      // always set child pointer to 0 on new levels\n      let childSetPointer = 0;\n\n      for (let j = 0; j < trees[t].treeTypes[i].length; j++) {\n        const childSet = trees[t].treeTypes[i][j];\n        if (childSet.length === 0) {\n          // make the nodes also have an empty array\n          trees[t].treeNodes[i][j] = [];\n          continue;\n        }\n\n        // otherwise loop through children\n        for (let k = 0; k < trees[t].treeTypes[i][j].length; k++) {\n          // extract children\n          const currentChildrenArray = trees[t].treeTypes[i + 1][childSetPointer];\n\n          // create children and assign the currentAccount as the parent\n          for (let child = 0; child < currentChildrenArray.length; child++) {\n            // create a basic account\n            const accountType = trees[t].treeTypes[i + 1][childSetPointer][child];\n\n            let currentAccount;\n            switch (accountType) {\n            case 's':\n              currentAccount = net.nanopay.account.ShadowAccount.create({\n                name: `${trees[t].name} Shadow [${i + 1}][${childSetPointer}][${child}]`,\n                owner: userId,\n                denomination: accountCurrencySequence[accountCurrencyPointer++],\n                liquiditySetting: liquiditySettingsSequence[liquiditySettingsPointer++],\n                // shadows don't need parents\n              }, x)\n              break;\n            case 'a':\n              currentAccount = net.nanopay.account.AggregateAccount.create({\n                name: `${trees[t].name} Aggregate [${i + 1}][${childSetPointer}][${child}]`,\n                owner: userId,\n                denomination: accountCurrencySequence[accountCurrencyPointer++],\n                liquiditySetting: liquiditySettingsSequence[liquiditySettingsPointer++],\n                parent: trees[t].treeNodes[i][j][k].id,\n              }, x)\n              break;\n            case 'v':\n              currentAccount = net.nanopay.account.DigitalAccount.create({\n                name: `${trees[t].name} Virtual [${i + 1}][${childSetPointer}][${child}]`,\n                owner: userId,\n                denomination: accountCurrencySequence[accountCurrencyPointer++],\n                liquiditySetting: liquiditySettingsSequence[liquiditySettingsPointer++],\n                parent: trees[t].treeNodes[i][j][k].id,\n              }, x)\n              break;\n            default:\n              currentAccount = null;\n              break;\n            }\n            // store the node\n            trees[t].treeNodes[i + 1][childSetPointer][child] = await accountDAO.put(currentAccount);\n\n            // transfer 100000 from shadow to this account\n            const currentTransaction = net.nanopay.tx.model.Transaction.create({\n              sourceAccount: trees[t].treeNodes[0][0][0].id,\n              destinationAccount: trees[t].treeNodes[i + 1][childSetPointer][child].id,\n              amount: accountBalanceSequence[accountBalancePointer++],\n              createdBy: userId,\n              payerId: userId,\n              payeeId: userId,\n              completionDate: variedCompletedTime\n            }, x);\n\n            // update varied completed time to an hour before\n            variedCompletedTime = new Date(variedCompletedTime.getTime() - 3600000);\n\n            transactionDAO.put(currentTransaction);\n\n            // reset account balance pointer if it now exceeds the accountBalanceSequence\n            if (accountBalancePointer >= accountBalanceSequence.length) accountBalancePointer = 0;\n            if (accountCurrencyPointer >= accountCurrencySequence.length) accountCurrencyPointer = 0;\n            if (liquiditySettingsPointer >= liquiditySettingsSequence.length) liquiditySettingsPointer = 0;\n          }\n\n          // increment child set pointer to match the jth node in the parent level\n          childSetPointer++;\n        }\n      }\n    }\n  }\n\n  print(\"[=====================           ] 65%\")\n\n  print();\n\n  //\n  // â”€â”€â”€ TRANSACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  //\n  // transactions to upload\n  // if making a scheduled transaction, we will need to make enable it in the journal services first\n\n  const mainTree = trees[0];\n  const secondaryTree = trees[1];\n\n  const specialTransactions = [\n    // V to V\n    {\n      sourceAccount: mainTree.treeNodes[1][0][2].id,\n      destinationAccount: mainTree.treeNodes[1][0][1].id,\n      amount: 1000000,\n      createdBy: userId,\n      payerId: userId,\n      payeeId: userId,\n      completionDate: currentDate\n    },\n\n    // V to S\n    {\n      sourceAccount: mainTree.treeNodes[2][0][1].id,\n      destinationAccount: mainTree.treeNodes[0][0][0].id,\n      amount: 5000000,\n      createdBy: userId,\n      payerId: userId,\n      payeeId: userId,\n      completionDate: currentDate\n    },\n\n    // S to V\n    {\n      sourceAccount: mainTree.treeNodes[0][0][0].id,\n      destinationAccount: mainTree.treeNodes[4][7][1].id,\n      amount: 2000000,\n      createdBy: userId,\n      payerId: userId,\n      payeeId: userId,\n      completionDate: currentDate\n    },\n\n    // S to other tree S\n    {\n      sourceAccount: secondaryTree.treeNodes[0][0][0].id,\n      destinationAccount: mainTree.treeNodes[0][0][0].id,\n      amount: 3000000,\n      createdBy: userId,\n      payerId: userId,\n      payeeId: userId,\n      completionDate: currentDate\n    },\n\n    // V to other tree V\n    {\n      sourceAccount: mainTree.treeNodes[2][0][1].id,\n      destinationAccount: secondaryTree.treeNodes[1][0][1].id,\n      amount: 5000000,\n      createdBy: userId,\n      payerId: userId,\n      payeeId: userId,\n      completionDate: currentDate\n    }\n  ];\n\n  // creating the special transactions\n  specialTransactions.forEach(transactionData => {\n    const currentTransaction = net.nanopay.tx.model.Transaction.create(transactionData, x);\n    transactionDAO.put(currentTransaction);\n  })\n\n  // creating the bulk transactions based  on the numberOfBulkTransactions\n  let totalTransactions = 0;\n  let transactionAmountPointer = 0;\n\n  const mainTreeNodes = mainTree.treeNodes;\n  const mainTreeTypes = mainTree.treeTypes;\n\n  while (totalTransactions < numberOfBulkTransactions) {\n    for (let i = 1; i < mainTreeNodes.length; i++) {\n      for (let j = 0; j < mainTreeNodes[i].length; j++) {\n        for (let k = 0; k < mainTreeNodes[i][j].length; k++) {\n          // skip sending to aggregates\n          if (mainTreeTypes[i][j][k] === 'a') continue;\n\n          const currentTransaction = net.nanopay.tx.model.Transaction.create({\n            sourceAccount: mainTreeNodes[0][0][0].id,\n            destinationAccount: mainTreeNodes[i][j][k].id,\n            amount: transactionAmountSequence[transactionAmountPointer++],\n            createdBy: userId,\n            payerId: userId,\n            payeeId: userId,\n            completionDate: variedCompletedTime\n          }, x);\n\n          // update varied completed time to an hour before\n          variedCompletedTime = new Date(variedCompletedTime.getTime() - 3600000)\n\n          transactionDAO.put(currentTransaction);\n\n          totalTransactions++;\n\n          if (totalTransactions % 100 === 0) print(`###### Completed ${totalTransactions} Transactions ######`);\n          if (transactionAmountPointer >= transactionAmountSequence.length) transactionAmountPointer = 0;\n        }\n      }\n    }\n  }\n  print();\n\n  print(\"[================================] 100% ðŸ”¥\");\n  print();\n\n  print('################################')\n  print('================================')\n  print('FINISHED SCRIPT ðŸ’¯ðŸ’¯ðŸ’¯');\n  print('================================')\n  print('################################')\n}\n//\n// â”€â”€â”€ HELPER FUNCTIONS AND INSTANCE VARIABLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n//\n\nconst addMinutes = (date, minutes) => new Date(date.getTime() + minutes * 60000);\n\n// initialize instance variables\nconst currentDate = new Date();\nconst scheduledTimeLater = addMinutes(currentDate, scheduledTimeLaterMinutes);\nconst scheduledTimeSoon = addMinutes(currentDate, scheduledTimeSoonMinutes);\nlet variedCompletedTime = currentDate;\nlet userId;\n\nmain();\n"})
