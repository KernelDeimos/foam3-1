p({"class": "foam.nanos.test.Test", "id": "Contact Tests", "description": "Tests related to contacts.", "server": false, "code": "/**\n * Tests for the Contacts feature.\n */\n\nrunTests();\n\nasync function runTests() {\n  var adminContext = x;\n\n  await resetTestData();\n  await Cannot_Create_Contact_Without_First_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_Long_First_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_First_Name_Containing_Number(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Without_Last_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_Long_Last_Name(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_With_Last_Name_Containing_Number(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Without_Organization(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Without_Email(adminContext);\n  await resetTestData();\n  await Cannot_Create_Contact_Invalid_Email(adminContext);\n  await resetTestData();\n  await Cannot_Create_Second_Contact_With_Same_Email(adminContext);\n  await resetTestData();\n  await Can_Create_Contact(adminContext);\n  await resetTestData();\n  await Can_Update_Contact(adminContext);\n}\n\nasync function resetTestData() {\n  // Delete the test contacts.\n  await x.contactDAO\n    .where(foam.mlang.predicate.Eq.create({\n      arg1: net.nanopay.contacts.Contact.EMAIL,\n      arg2: 'devon@example.com'\n    }))\n    .removeAll_(x, 0, 1000, null, null);\n}\n\n/**\n * Utility method for tests that check if an error was thrown. \n */\nasync function Test_Throws(testText, expectedErrorMessage, fn) {\n  var threw = false;\n  var actualErrorMessage = '';\n  try {\n    await fn();\n  } catch(err) {\n    threw = true;\n    actualErrorMessage = err.message;\n  }\n  test(threw && actualErrorMessage === expectedErrorMessage, testText);\n  if ( threw && actualErrorMessage !== expectedErrorMessage ) {\n    print(`INFO: Expected to get '${expectedErrorMessage}' as the error message but got '${actualErrorMessage}' instead.`);\n  } else if ( ! threw  ) {\n    print(`INFO: Didn't throw an error.`);\n  }\n}\n\nasync function Cannot_Create_Contact_Without_First_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact without `firstName`, a required field.',\n    'First name is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Long_First_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact with a first name longer than 70 characters.',\n    'First name cannot exceed 70 characters.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_First_Name_Containing_Number(context) {\n  await Test_Throws(\n    'Cannot create a contact with a first name that contains a number.',\n    'First name cannot contain numbers.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: '5up3rm4n',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Last_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact without `lastName`, a required field.',\n    'Last name is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Long_Last_Name(context) {\n  await Test_Throws(\n    'Cannot create a contact with a last name longer than 70 characters.',\n    'Last name cannot exceed 70 characters.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_With_Last_Name_Containing_Number(context) {\n  await Test_Throws(\n    'Cannot create a contact with a last name that contains a number.',\n    'Last name cannot contain numbers.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: '5up3rm4n',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Organization(context) {\n  await Test_Throws(\n    'Cannot create a contact without `organization`, a required field.',\n    'Organization is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Without_Email(context) {\n  await Test_Throws(\n    'Cannot create a contact without `email`, a required field.',\n    'Email is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Contact_Invalid_Email(context) {\n  await Test_Throws(\n    'Cannot create a contact with an empty string for an email address.',\n    'Email is required.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: '',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n  await Test_Throws(\n    'Cannot create a contact without anything before the @ in an email address.',\n    'Invalid email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: '@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n  await Test_Throws(\n    'Cannot create a contact with only a TLD in the email address.',\n    'Invalid email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Cannot_Create_Second_Contact_With_Same_Email(context) {\n  await Test_Throws(\n    'Cannot create two contacts with the same email address.',\n    'You already have a contact with that email address.',\n    async () => {\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'Carlyle',\n        organization: 'ExampleCo'\n      }));\n      await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n        email: 'devon@example.com',\n        firstName: 'Devon',\n        lastName: 'OtherGuy',\n        organization: 'ExampleCo'\n      }))\n    }\n  );\n}\n\nasync function Can_Create_Contact(context) {\n  var threw = false;\n  var result;\n  try {\n    result = await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n      email: 'devon@example.com',\n      firstName: 'Devon',\n      lastName: 'Carlyle',\n      organization: 'ExampleCo'\n    }));\n  } catch (err) {\n    threw = true;\n  }\n  var passed = ! threw &&\n    result.email === 'devon@example.com' &&\n    result.firstName === 'Devon' &&\n    result.lastName === 'Carlyle' &&\n    result.organization === 'ExampleCo';\n  test(passed, `User in '${context.user.group}' group can create a contact.`);\n}\n\nasync function Can_Update_Contact(context) {\n  var threw = false;\n  var result = await context.user.contacts.put(net.nanopay.contacts.Contact.create({\n    email: 'devon@example.com',\n    firstName: 'Devon',\n    lastName: 'Carlyle',\n    organization: 'ExampleCo'\n  }));\n  try {\n    result.organization = 'Different';\n    result = await context.user.contacts.put(result);\n  } catch (err) {\n    threw = true;\n    print(err.message);\n  }\n  var passed = ! threw &&\n    result.email === 'devon@example.com' &&\n    result.firstName === 'Devon' &&\n    result.lastName === 'Carlyle' &&\n    result.organization === 'Different';\n  test(passed, `User in '${context.user.group}' group can update a contact.`);\n}\n"})
p({"class": "net.nanopay.contacts.AuthenticatedContactDAOTest", "id": "AuthenticatedContactDAOTest", "description": "Tests the functionality of the AuthenticatedContactDAO DAO decorator."})
p({"class":"foam.nanos.test.Test","id":"Accept contact payment test","status":2,"code":"import foam.dao.ArraySink;\nimport foam.mlang.predicate.*;\nimport foam.nanos.auth.User;\nimport net.nanopay.contacts.Contact;\nimport net.nanopay.invoice.model.Invoice;\nimport net.nanopay.account.Account;\nimport net.nanopay.bank.CABankAccount;\nimport net.nanopay.account.HoldingAccount;\nimport net.nanopay.tx.model.Transaction;\nimport net.nanopay.tx.model.TransactionStatus;\nimport net.nanopay.bank.BankAccountStatus;\nimport net.nanopay.invoice.model.InvoiceStatus;\nimport net.nanopay.invoice.model.PaymentStatus;\n\nuser = x.get(\"user\");\nuserDAO = x.get(\"localUserDAO\");\naccountDAO = x.get(\"localAccountDAO\");\ncontactDAO = x.get(\"localContactDAO\");\ntransactionDAO = x.get(\"localTransactionDAO\");\nauth = x.get(\"auth\");\nliquiditySettingsDAO = x.get(\"liquiditySettingsDAO\");\n\n// Try to remove the existing test user if there is one.\nuserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"fox@example.com\")).removeAll();\n\n// Try to remove the existing source bank account if there is one.\naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"Holding account test account\")).removeAll();\n\n// Create the test bank account to send money from.\naccount = new CABankAccount();\naccount.setName(\"Holding account test account\");\naccount.setDenomination(\"CAD\");\naccount.setAccountNumber(\"12345678\");\naccount.setInstitution(1);\naccount.setBranchId(\"12345\");\naccount.setStatus(BankAccountStatus.VERIFIED);\naccount = user.getAccounts(x).put(account);\n\n// Try to remove the existing contact if there is one.\ncontactDAO.where(foam.mlang.MLang.EQ(Contact.EMAIL, \"fox@example.com\")).removeAll();\n\n// Create the test contact to send money to.\ncontact = new Contact();\ncontact.setEmail(\"fox@example.com\");\ncontact.setFirstName(\"Fox\");\ncontact.setLastName(\"McCloud\");\ncontact.setOrganization(\"Example Company\");\nfox = user.getContacts(x).put(contact);\n\n// Try to remove the existing holding account if there is one.\naccountDAO.where(foam.mlang.MLang.INSTANCE_OF(HoldingAccount.class)).removeAll();\n\n// Create a payable invoice with the contact as the payee.\ninvoice = new Invoice();\ninvoice.setPayeeId(fox.getId());\ninvoice.setAmount(1);\ninvoice.setDestinationCurrency(\"CAD\");\ninvoice = user.getExpenses(x).put(invoice);\n\n// Check that the holding account was created.\nPredicate[] predicates = new Predicate[2];\npredicates[0] = foam.mlang.MLang.INSTANCE_OF(HoldingAccount.class);\npredicates[1] = foam.mlang.MLang.EQ(HoldingAccount.INVOICE_ID, invoice.getId());\nquery = new And(predicates);\nholdingAccounts = accountDAO.where(query).select().getArray();\ntest(holdingAccounts.size() == 1, \"A holding account was created for the invoice.\");\nHoldingAccount holdingAccount;\nif ( holdingAccounts.size() > 0 ) {\nholdingAccount = holdingAccounts.get(0);\n} else {\nprint(\"DEBUG: holdingAccounts.size() = \" + holdingAccounts.size().toString());\n}\nls = new net.nanopay.tx.model.LiquiditySettings();\nls.setId(holdingAccount.getId());\nls.setEnableCashIn(false);\nls.setEnableCashOut(false);\nliquiditySettingsDAO.put(ls);\n// Pay the invoice.\ntxn = new Transaction();\ntxn.setDestinationAccount(holdingAccount.getId());\ntxn.setInvoiceId(invoice.getId());\ntxn.setAmount(invoice.getAmount());\ntxn.setSourceAccount(account.getId());\ntxn.setStatus(TransactionStatus.COMPLETED);\ntxn = transactionDAO.put_(x, txn);\n\n// Check that the money moved to the holding account.\nholdingAccount = accountDAO.find_(x, holdingAccount.getId());\ntest(holdingAccount.findBalance(x) == 1, \"Money was moved to the holding account.\");\n\n// Test that the invoice statuses were set.\ninvoice = user.getExpenses(x).find(invoice.getId());\ntest(invoice.getPaymentMethod() == PaymentStatus.HOLDING && invoice.getStatus() == InvoiceStatus.PENDING_ACCEPTANCE, \"The invoice statuses are both correct after paying the invoice.\");\n\n// Payee signs up.\n\n// Create the test user to send accept the money.\nrealUser = new User();\nrealUser.setEmail(\"fox@example.com\");\nrealUser.setFirstName(\"Fox\");\nrealUser.setEmailVerified(true);\nrealUser.setLastName(\"McCloud\");\nrealUser.setGroup(\"business\");\nrealUser = userDAO.put(realUser);\n\nrealUserContext = sudo(\"fox@example.com\");\n\n// Payee adds a bank account.\n\n// Try to remove the existing source bank account if there is one.\naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"Holding account test: real user bank account\")).removeAll();\n\n// Create the test bank account to send money from.\nrealUserBankAccount = new CABankAccount();\nrealUserBankAccount.setName(\"Holding account test: real user bank account\");\nrealUserBankAccount.setDenomination(\"CAD\");\nrealUserBankAccount.setAccountNumber(\"12345678\");\nrealUserBankAccount.setInstitution(1);\nrealUserBankAccount.setBranchId(\"12345\");\nrealUserBankAccount.setStatus(BankAccountStatus.VERIFIED);\nrealUserBankAccount = realUser.getAccounts(realUserContext).put(realUserBankAccount);\n\n// Payee accepts the payment.\nacceptTxn = new Transaction();\nacceptTxn.setDestinationAccount(realUserBankAccount.getId());\nacceptTxn.setInvoiceId(invoice.getId());\nacceptTxn.setAmount(invoice.getAmount());\nacceptTxn.setSourceAccount(holdingAccount.getId());\nacceptTxn.setStatus(TransactionStatus.COMPLETED);\nacceptTxn = transactionDAO.put_(realUserContext, acceptTxn);\n\n// Test that the invoice status has been set from PENDING_ACCEPTANCE to DONE. \ntxn = new Transaction();\ntxn.setDestinationAccount(holdingAccount.getId()); \ntxn.setInvoiceId(invoice.getId()); \ntxn.setAmount(50);\ntxn.setSourceAccount(1); \ntxn.setStatus(TransactionStatus.COMPLETED); \ntxn = transactionDAO.put(txn); \n
 \ninvoice = user.getExpenses(x).find(invoice.getId());\ntest(invoice.getPaymentMethod() == PaymentStatus.NANOPAY && invoice.getStatus() == InvoiceStatus.PAID, \"The statuses are all correct.\");\n\n// Test that the money moved from the holding account to the real payee's account.\nholdingAccount = accountDAO.find(holdingAccount.getId());\ntest(holdingAccount.findBalance(x) == 0, \"Money was moved from the holding account.\");\n","output":""})
p({"class":"foam.nanos.test.Test","id":"Cancel HoldingAccount invoice Payment","description":"Testing the functionality placed in RevertInvoicePaymentInHoldingAccountDecorator which decorates invoiceDAO. This test confirms the replacement of funds from user owned HoldingAccount to user owned Account ","status":2,"code":"import foam.dao.ArraySink; \nimport foam.mlang.predicate.*; \nimport foam.nanos.auth.User; \nimport net.nanopay.contacts.Contact; \nimport net.nanopay.invoice.model.Invoice; \nimport net.nanopay.account.Account; \nimport net.nanopay.bank.CABankAccount; \nimport net.nanopay.account.HoldingAccount; \nimport net.nanopay.tx.model.Transaction; \nimport net.nanopay.tx.model.TransactionStatus; \nimport net.nanopay.bank.BankAccountStatus; \nimport net.nanopay.invoice.model.InvoiceStatus; \nimport net.nanopay.invoice.model.PaymentStatus; \nimport net.nanopay.model.Currency; \nimport org.apache.commons.lang.StringUtils; \nString msg = \"\"; \nuser = x.get(\"user\"); \nuserDAO = x.get(\"localUserDAO\"); \ninvoiceDAO_ = x.get(\"invoiceDAO\"); \naccountDAO = x.get(\"localAccountDAO\"); \ncontactDAO = x.get(\"contactDAO\"); \ntransactionDAO = x.get(\"localTransactionDAO\"); \nuserDAO.where(foam.mlang.MLang.EQ(User.EMAIL, \"fox@example.com\")).removeAll(); \naccountDAO.where(foam.mlang.MLang.EQ(Account.NAME, \"Holding account test account\")).removeAll(); \naccount = new CABankAccount(); \naccount.setName(\"Holding account test account\"); \naccount.setDenomination(\"CAD\"); \naccount.setAccountNumber(\"12345678\"); \naccount.setInstitution(1); \naccount.setBranchId(\"12345\"); \naccount.setStatus(BankAccountStatus.VERIFIED); \naccount = user.getAccounts(x).put(account); \ncontactDAO.where(foam.mlang.MLang.EQ(Contact.EMAIL, \"fox@example.com\")).removeAll(); \ncontact = new Contact(); \ncontact.setEmail(\"fox@example.com\"); \ncontact.setFirstName(\"Fox\"); \ncontact.setLastName(\"McCloud\"); \ncontact.setOrganization(\"Example Company\"); \nfox = user.getContacts(x).put(contact); \naccountDAO.where(foam.mlang.MLang.INSTANCE_OF(HoldingAccount.class)).removeAll(); \ninvoice = new Invoice(); \ninvoice.setPayeeId(fox.getId()); \ninvoice.setAmount(1); \ninvoice.setDestinationCurrency(\"CAD\"); \ninvoice = user.getExpenses(x).put(invoice); \nPredicate[] predicates = new Predicate[2]; \npredicates[0] = foam.mlang.MLang.INSTANCE_OF(HoldingAccount.class); \npredicates[1] = foam.mlang.MLang.EQ(HoldingAccount.INVOICE_ID, invoice.getId()); \nPredicate query = new And(predicates); \nholdingAccounts = accountDAO.where(query).select().getArray(); \nif(holdingAccounts.size() == 1) {msg = \"A holding account was created for the invoice.\"; \n} HoldingAccount holdingAccount; \nif ( holdingAccounts.size() > 0 ) {holdingAccount = holdingAccounts.get(0); \n} else {System.out.println(\"DEBUG: holdingAccounts.size() = \" + holdingAccounts.size().toString()); \n}\nls = new net.nanopay.tx.model.LiquiditySettings();\nls.setEnableCashIn(false);\nls.setEnableCashOut(false);\nls.setId(holdingAccount.getId());\nx.get(\"liquiditySettingsDAO\").put(ls);\ntxn = new Transaction(); \ntxn.setDestinationAccount(holdingAccount.getId()); \ntxn.setInvoiceId(invoice.getId()); \ntxn.setAmount(invoice.getAmount());\ntxn.setSourceAccount(account.getId()); \ntxn.setStatus(TransactionStatus.COMPLETED); \ntxn = transactionDAO.put(txn); \nholdingAccount = accountDAO.find(holdingAccount.getId()); \nif(holdingAccount.findBalance(x) == 1) {\n msg += \"Anna Money was moved to the holding account.\"; txn = new Transaction();\ntxn.setDestinationAccount(holdingAccount.getId()); \ntxn.setInvoiceId(invoice.getId()); \ntxn.setAmount(50);\ntxn.setSourceAccount(1); \ntxn.setStatus(TransactionStatus.COMPLETED); \ntxn = transactionDAO.put(txn); \n
 \n}invoice = user.getExpenses(x).find(invoice.getId()); \nif(invoice.getPaymentMethod() == PaymentStatus.HOLDING && invoice.getStatus() == InvoiceStatus.PENDING_ACCEPTANCE) {msg += \"The invoice statuses are both correct after paying the invoice.\"; \n}invoice.setPaymentMethod(PaymentStatus.NONE); \ninvoiceDAO_.put_(x, invoice); \nholdingAccount = accountDAO.find(holdingAccount.getId()); \ncount = StringUtils.countMatches(msg, \".\"); \ntest( count == 3 && holdingAccount.findBalance(x) == 0, \"Balance of Holding = \"+ holdingAccount.findBalance(x)+\" Money was moved out of the holding account.\");\n","output":""})
