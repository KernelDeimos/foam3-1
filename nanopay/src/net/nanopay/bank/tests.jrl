// net.nanopay.bank.BankAccountInstitutionDAOTest
p({
  "class":"foam.nanos.test.Test",
  "passed":0,
  "failed":0,
  "id":"net.nanopay.bank.BankAccountInstitutionDAOTest",
  "enabled":true,
  "description":"",
  "lastRun":"2018-08-03T15:20:18.484Z",
  "lastDuration":1487,
  "server":true,
  "status":1,
  "code":"""
    institutionNumber = "net.nanopay.bank.BankAccountInstitutionTest";
    id = (foam.dao.DAO) x.get("institutionDAO");
    id = id.limit(1);
    id = id.where(
      foam.mlang.MLang.EQ(net.nanopay.payment.Institution.INSTITUTION_NUMBER, institutionNumber)
    );
    il = ((foam.dao.ArraySink) id.select(new foam.dao.ArraySink())).getArray();
    if ( il.size() > 0 ) {
      print("cleaning up previous run");
      id.remove(il.get(0));
    };
    
    bd = (foam.dao.DAO) x.get("localAccountDAO");
    bd = bd.where(
      foam.mlang.MLang.EQ(net.nanopay.account.Account.NAME, institutionNumber)
    );
    bl = ((foam.dao.ArraySink) bd.select(new foam.dao.ArraySink())).getArray();
    if ( bl.size() > 0 ) {
      bd.remove(bl.get(0));
      print("cleaning up previous run.");
    };
    
    u = (foam.nanos.auth.User) x.get("subject").getUser();
    b = new net.nanopay.bank.CABankAccount();
    b.setName(institutionNumber);
    b.setOwner(u.getId());
    b.setInstitutionNumber(institutionNumber);
    b.setAccountNumber(institutionNumber);
    b.setStatus(net.nanopay.bank.BankAccountStatus.VERIFIED);
    
    test(b.findInstitution(x) == null, "institution should not exist");
      
    b = bd.put(b);
    test( ! String.valueOf(b.getInstitution()).equals(institutionNumber), "institution reference should not equal number"); 
    list = ((foam.dao.ArraySink) id.select(new foam.dao.ArraySink())).getArray();
    test( list.size() == 1, "institution created");
    i = list.get(0);
    test( i.getInstitutionNumber().equals(institutionNumber), "matching institutionNumber");
  """
})
